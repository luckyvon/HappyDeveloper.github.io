<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="1、OC对象的本质1.1 OC底层实现我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。Objective-C的对象、类主要是基于C\C++的结构体实现。  1.2 将Objective-C代码转换为C\C++代码 xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件。如">
<meta name="keywords" content="iOS,OC">
<meta property="og:type" content="article">
<meta property="og:title" content="OC底层原理">
<meta property="og:url" content="http://yoursite.com/2019/04/27/OC底层原理/index.html">
<meta property="og:site_name" content="点滴">
<meta property="og:description" content="1、OC对象的本质1.1 OC底层实现我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。Objective-C的对象、类主要是基于C\C++的结构体实现。  1.2 将Objective-C代码转换为C\C++代码 xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件。如">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.3_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.3_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.3_4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.1_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.1_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.1_4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.1_5.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.6_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.7_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.7_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/2/2.7_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/3/3.0_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/3/3.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/3/3.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/3/3.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/3/3.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/4/4.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/4/4.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/5/5.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/5/5.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/6/6.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/6/6.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/6/6.4_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.2_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.3_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.3_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.7_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.8_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.8_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.8_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.8_4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.9_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.10_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.12_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.12.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.12.1_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.12.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/7/7.12.2_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.1.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.6_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.2.6_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.3.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.3.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.3.4_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.3.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/8/8.3.5_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.1.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.1.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.1.3_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.3.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.3.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.3.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.4_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.4_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/9/9.4_4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.1.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.1.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.1.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.3.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.3.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.3.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.3.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.5_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.5_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.5_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.5_4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.6_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.7_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.8_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.9_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.4.10_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.6.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/10/10.6.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.1.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.1.1_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.1.1_3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.1.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.2.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.2.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.2.3_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.3.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.3.1_2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.3.2_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.3.3_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.3.4_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.4.1_1.png">
<meta property="og:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/11/11.4.2_1.png">
<meta property="og:updated_time" content="2019-05-18T04:50:10.365Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OC底层原理">
<meta name="twitter:description" content="1、OC对象的本质1.1 OC底层实现我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。Objective-C的对象、类主要是基于C\C++的结构体实现。  1.2 将Objective-C代码转换为C\C++代码 xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件。如">
<meta name="twitter:image" content="http://yoursite.com/2019/04/27/OC底层原理/imgs/1/1.1_1.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/04/27/OC底层原理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>OC底层原理 | 点滴</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">点滴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">记录每一天</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/OC底层原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Luckyvon">
      <meta itemprop="description" content="不积跬步,无以至千里;不积小流,无以成江海。">
      <meta itemprop="image" content="/images/header.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="点滴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OC底层原理

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-27 20:15:09" itemprop="dateCreated datePublished" datetime="2019-04-27T20:15:09+08:00">2019-04-27</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OC/" itemprop="url" rel="index"><span itemprop="name">OC</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">69k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:02</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、OC对象的本质"><a href="#1、OC对象的本质" class="headerlink" title="1、OC对象的本质"></a>1、OC对象的本质</h1><h2 id="1-1-OC底层实现"><a href="#1-1-OC底层实现" class="headerlink" title="1.1 OC底层实现"></a>1.1 OC底层实现</h2><p>我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。Objective-C的对象、类主要是基于C\C++的结构体实现。</p>
<p><img src="/2019/04/27/OC底层原理/imgs/1/1.1_1.png" alt></p>
<h2 id="1-2-将Objective-C代码转换为C-C-代码"><a href="#1-2-将Objective-C代码转换为C-C-代码" class="headerlink" title="1.2 将Objective-C代码转换为C\C++代码"></a>1.2 将Objective-C代码转换为C\C++代码</h2><blockquote>
<p>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件。<br>如果需要链接其他框架，使用-framework参数。比如-framework UIKit</p>
</blockquote>
<h2 id="1-3-NSObject的底层实现"><a href="#1-3-NSObject的底层实现" class="headerlink" title="1.3 NSObject的底层实现"></a>1.3 NSObject的底层实现</h2><p><img src="/2019/04/27/OC底层原理/imgs/1/1.3_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/1/1.3_2.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/1/1.3_3.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/1/1.3_4.png" alt></p>
<h2 id="1-4-实时查看内存数据"><a href="#1-4-实时查看内存数据" class="headerlink" title="1.4 实时查看内存数据"></a>1.4 实时查看内存数据</h2><h3 id="1-4-1-ViewMemory"><a href="#1-4-1-ViewMemory" class="headerlink" title="1.4.1 ViewMemory"></a>1.4.1 ViewMemory</h3><p><img src="/2019/04/27/OC底层原理/imgs/1/1.4_1.png" alt></p>
<h3 id="1-4-2-LLDB指令"><a href="#1-4-2-LLDB指令" class="headerlink" title="1.4.2 LLDB指令"></a>1.4.2 LLDB指令</h3><blockquote>
<p>print、p：打印<br>po：打印对象</p>
<p>读取内存<br>memory read/数量格式字节数  内存地址<br>x/数量格式字节数  内存地址<br>x/3xw  0x10010</p>
<p>格式<br>x是16进制<br>f是浮点<br>d是10进制</p>
<p>字节大小<br>b：byte 1字节<br>h：half word 2字节<br>w：word 4字节<br>g：giant word 8字节</p>
<p>修改内存中的值<br>memory  write  内存地址  数值<br>memory  write  0x0000010  10</p>
</blockquote>
<h2 id="1-5-结构体内存分配"><a href="#1-5-结构体内存分配" class="headerlink" title="1.5 结构体内存分配"></a>1.5 结构体内存分配</h2><p><a href="http://www.cnblogs.com/xieyajie/p/8094788.html" target="_blank" rel="noopener">结构体大小计算</a></p>
<h2 id="1-6-sizeof注意点"><a href="#1-6-sizeof注意点" class="headerlink" title="1.6 sizeof注意点"></a>1.6 sizeof注意点</h2><p>sizeof是编译器特性，在编译的时候直接进行常理替换，并不是函数。class_getInstanceSize需要在运行时确定大小。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>1.1一个NSObject对象占用多少内存？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">// 16个字节</span><br><span class="line">    </span><br><span class="line">// 获得NSObject实例对象的成员变量所占用的大小 =8</span><br><span class="line">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));//8</span><br><span class="line">    </span><br><span class="line">// 系统分配了16个字节给NSObject对象</span><br><span class="line">//CF requires all objects be at least 16 bytes</span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));//16</span><br><span class="line"></span><br><span class="line">苹果系统分配内存源码</span><br><span class="line">https://opensource.apple.com/tarballs/libmalloc/</span><br><span class="line">malloc.c/calloc  Buckets sized &#123;16,32,64,80,96,112,...&#125;</span><br><span class="line">操作系统分配内存也有对齐，16的整数倍</span><br><span class="line"></span><br><span class="line">创建一个实例对象，至少需要多少内存？//结构体内存对齐</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">class_getInstanceSize([NSObject class]);</span><br><span class="line"></span><br><span class="line">建一个实例对象，实际上分配了多少内存？//操作系统分配内存也会对齐，16的整数倍</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line">malloc_size((__bridge const void *)obj);</span><br><span class="line"></span><br><span class="line">sizeof()也能计算出大小</span><br><span class="line"></span><br><span class="line">gnu（glibc/malloc/MALLOC_ALIGNMENT=16 c语言源码）是一个开源组织也提供了相关源码</span><br></pre></td></tr></table></figure>
<h1 id="2、OC对象的分类"><a href="#2、OC对象的分类" class="headerlink" title="2、OC对象的分类"></a>2、OC对象的分类</h1><h2 id="2-1-Objective-C中的对象，简称OC对象，主要可以分为3种"><a href="#2-1-Objective-C中的对象，简称OC对象，主要可以分为3种" class="headerlink" title="2.1 Objective-C中的对象，简称OC对象，主要可以分为3种"></a>2.1 Objective-C中的对象，简称OC对象，主要可以分为3种</h2><ul>
<li>instance对象（实例对象）</li>
<li>class对象（类对象）</li>
<li>meta-class对象（元类对象） </li>
</ul>
<h3 id="2-1-1-instance"><a href="#2-1-1-instance" class="headerlink" title="2.1.1 instance"></a>2.1.1 instance</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.1_1.png" alt></p>
<h3 id="2-1-2-class"><a href="#2-1-2-class" class="headerlink" title="2.1.2 class"></a>2.1.2 class</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.1_2.png" alt></p>
<h3 id="2-1-3-meta-class"><a href="#2-1-3-meta-class" class="headerlink" title="2.1.3 meta-class"></a>2.1.3 meta-class</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.1_3.png" alt></p>
<h3 id="2-1-4-注意"><a href="#2-1-4-注意" class="headerlink" title="2.1.4 注意"></a>2.1.4 注意</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.1_4.png" alt></p>
<h3 id="2-1-5-查看Class是否为meta-class"><a href="#2-1-5-查看Class是否为meta-class" class="headerlink" title="2.1.5 查看Class是否为meta-class"></a>2.1.5 查看Class是否为meta-class</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.1_5.png" alt></p>
<h2 id="2-2-object-getClass内部实现"><a href="#2-2-object-getClass内部实现" class="headerlink" title="2.2 object_getClass内部实现"></a>2.2 object_getClass内部实现</h2><p><a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/</a><br>objc4/objc-runtime.mm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 1.Class objc_getClass(const char *aClassName)</span><br><span class="line"> 1&gt; 传入字符串类名</span><br><span class="line"> 2&gt; 返回对应的类对象</span><br><span class="line"> </span><br><span class="line"> 2.Class object_getClass(id obj)</span><br><span class="line"> 1&gt; 传入的obj可能是instance对象、class对象、meta-class对象</span><br><span class="line"> 2&gt; 返回值</span><br><span class="line"> a) 如果是instance对象，返回class对象</span><br><span class="line"> b) 如果是class对象，返回meta-class对象</span><br><span class="line"> c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</span><br><span class="line"> </span><br><span class="line"> 3.- (Class)class、+ (Class)class</span><br><span class="line"> 1&gt; 返回的就是类对象</span><br><span class="line"> </span><br><span class="line"> - (Class) &#123;</span><br><span class="line">     return self-&gt;isa;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> + (Class) &#123;</span><br><span class="line">     return self;</span><br><span class="line"> &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="2-3-isa指针"><a href="#2-3-isa指针" class="headerlink" title="2.3 isa指针"></a>2.3 isa指针</h2><p><img src="/2019/04/27/OC底层原理/imgs/2/2.3_1.png" alt></p>
<h2 id="2-4-class对象的superclass指针"><a href="#2-4-class对象的superclass指针" class="headerlink" title="2.4 class对象的superclass指针"></a>2.4 class对象的superclass指针</h2><p><img src="/2019/04/27/OC底层原理/imgs/2/2.4_1.png" alt></p>
<h2 id="2-5-meta-class对象的superclass指"><a href="#2-5-meta-class对象的superclass指" class="headerlink" title="2.5 meta-class对象的superclass指"></a>2.5 meta-class对象的superclass指</h2><p><img src="/2019/04/27/OC底层原理/imgs/2/2.5_1.png" alt></p>
<h2 id="2-6-isa、superclass总结"><a href="#2-6-isa、superclass总结" class="headerlink" title="2.6 isa、superclass总结"></a>2.6 isa、superclass总结</h2><p><img src="/2019/04/27/OC底层原理/imgs/2/2.6_1.png" alt></p>
<h2 id="2-7-class结构体"><a href="#2-7-class结构体" class="headerlink" title="2.7 class结构体"></a>2.7 class结构体</h2><h3 id="2-7-1-isa指针"><a href="#2-7-1-isa指针" class="headerlink" title="2.7.1 isa指针"></a>2.7.1 isa指针</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.7_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct mj_objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">        // MJPerson类对象的地址：0x00000001000014c8</span><br><span class="line">        // isa &amp; ISA_MASK：0x00000001000014c8</span><br><span class="line">        </span><br><span class="line">        // MJPerson实例对象的isa：0x001d8001000014c9</span><br><span class="line">        </span><br><span class="line">        struct mj_objc_class *personClass = (__bridge struct mj_objc_class *)([MJPerson class]);</span><br><span class="line">        </span><br><span class="line">        struct mj_objc_class *studentClass = (__bridge struct mj_objc_class *)([MJStudent class]);</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">        </span><br><span class="line">//        MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">//</span><br><span class="line">        </span><br><span class="line">//        Class personClass = [MJPerson class];</span><br><span class="line">        </span><br><span class="line">//        struct mj_objc_class *personClass2 = (__bridge struct mj_objc_class *)(personClass);</span><br><span class="line">//</span><br><span class="line">//        Class personMetaClass = object_getClass(personClass);</span><br><span class="line">//</span><br><span class="line">//        NSLog(@&quot;%p %p %p&quot;, person, personClass, personMetaClass);</span><br><span class="line">//        MJStudent *student = [[MJStudent alloc] init];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">64bit之前isa = 对象地址，从64bit开始，isa需要进行一次位运算，才能计算出真实地址	</span><br><span class="line">p/x (long)person-&gt;isa</span><br><span class="line">输出</span><br><span class="line">0x001d8001000014c9</span><br><span class="line"></span><br><span class="line">p/x persionClass </span><br><span class="line">输出</span><br><span class="line">0x00000001000014c8</span><br><span class="line"></span><br><span class="line">p/x 0x001d8001000014c9 &amp; 0x00007ffffffffff8（x86下ISA_MASK）</span><br><span class="line">输出</span><br><span class="line">0x00000001000014c8</span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-objc4源码下载"><a href="#2-7-2-objc4源码下载" class="headerlink" title="2.7.2 objc4源码下载"></a>2.7.2 objc4源码下载</h3><ul>
<li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a><br><img src="/2019/04/27/OC底层原理/imgs/2/2.7_2.png" alt></li>
<li>class、meta-class对象的本质结构都是struct objc_class</li>
</ul>
<h3 id="2-7-3-窥探struct-objc-class的结构"><a href="#2-7-3-窥探struct-objc-class的结构" class="headerlink" title="2.7.3 窥探struct objc_class的结构"></a>2.7.3 窥探struct objc_class的结构</h3><p><img src="/2019/04/27/OC底层原理/imgs/2/2.7_3.png" alt></p>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>对象的isa指针指向哪里？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance对象的isa指向class对象</span><br><span class="line">class对象的isa指向meta-class对象</span><br><span class="line">meta-class对象的isa指向基类的meta-class对象</span><br></pre></td></tr></table></figure>
<ul>
<li>OC的类信息存放在哪里？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象方法、属性、成员变量、协议信息，存放在class对象中</span><br><span class="line">类方法，存放在meta-class对象中</span><br><span class="line">成员变量的具体值，存放在instance对象</span><br></pre></td></tr></table></figure>
<h1 id="3、KVO"><a href="#3、KVO" class="headerlink" title="3、KVO"></a>3、KVO</h1><blockquote>
<p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p>
</blockquote>
<p><img src="/2019/04/27/OC底层原理/imgs/3/3.0_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (strong, nonatomic) MJPerson *person1;</span><br><span class="line">@property (strong, nonatomic) MJPerson *person2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.person1 = [[MJPerson alloc] init];</span><br><span class="line">    self.person1.age = 1;</span><br><span class="line">    self.person1.height = 11;</span><br><span class="line">    </span><br><span class="line">    self.person2 = [[MJPerson alloc] init];</span><br><span class="line">    self.person2.age = 2;</span><br><span class="line">    self.person2.height = 22;</span><br><span class="line">    </span><br><span class="line">    // 给person1对象添加KVO监听</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;height&quot; options:options context:@&quot;456&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    self.person1.age = 20;</span><br><span class="line">    self.person2.age = 20;</span><br><span class="line">    </span><br><span class="line">    self.person1.height = 30;</span><br><span class="line">    self.person2.height = 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;height&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-未使用KVO监听的对象"><a href="#3-1-未使用KVO监听的对象" class="headerlink" title="3.1 未使用KVO监听的对象"></a>3.1 未使用KVO监听的对象</h2><p><img src="/2019/04/27/OC底层原理/imgs/3/3.1_1.png" alt></p>
<h2 id="3-2-使用了KVO监听的对象"><a href="#3-2-使用了KVO监听的对象" class="headerlink" title="3.2 使用了KVO监听的对象"></a>3.2 使用了KVO监听的对象</h2><p><img src="/2019/04/27/OC底层原理/imgs/3/3.2_1.png" alt></p>
<h2 id="3-3-查看-NSSet-AndNotify的存在"><a href="#3-3-查看-NSSet-AndNotify的存在" class="headerlink" title="3.3 查看_NSSet*AndNotify的存在"></a>3.3 查看_NSSet*AndNotify的存在</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">- (void)setAge:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;setAge:&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//- (int)age</span><br><span class="line">//&#123;</span><br><span class="line">//    return _age;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;willChangeValueForKey&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey - begin&quot;);</span><br><span class="line">    </span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;didChangeValueForKey - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.person1 = [[MJPerson alloc] init];</span><br><span class="line">    self.person1.age = 1;</span><br><span class="line">    </span><br><span class="line">    self.person2 = [[MJPerson alloc] init];</span><br><span class="line">    self.person2.age = 2;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//    NSLog(@&quot;person1添加KVO监听之前1 - %@ %@&quot;,</span><br><span class="line">//          object_getClass(self.person1),</span><br><span class="line">//          object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">//    NSLog(@&quot;person1添加KVO监听之前2 - %p %p&quot;,</span><br><span class="line">//          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">//          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">    </span><br><span class="line">    // 给person1对象添加KVO监听</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line">    </span><br><span class="line">//    NSLog(@&quot;person1添加KVO监听之后1 - %@ %@&quot;,</span><br><span class="line">//          object_getClass(self.person1),</span><br><span class="line">//          object_getClass(self.person2));</span><br><span class="line">//    NSLog(@&quot;person1添加KVO监听之后2 - %p %p&quot;,</span><br><span class="line">//          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">//          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;类对象 - %@ %@&quot;,</span><br><span class="line">//          object_getClass(self.person1),  // self.person1.isa</span><br><span class="line">//          object_getClass(self.person2)); // self.person2.isa</span><br><span class="line">//    NSLog(@&quot;类对象 - %p %p&quot;,</span><br><span class="line">//          object_getClass(self.person1),  // self.person1.isa</span><br><span class="line">//          object_getClass(self.person2)); // self.person2.isa</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;元类对象 - %@ %@&quot;,</span><br><span class="line">//          object_getClass(object_getClass(self.person1)), // self.person1.isa.isa</span><br><span class="line">//          object_getClass(object_getClass(self.person2))); // self.person2.isa.isa</span><br><span class="line">//    NSLog(@&quot;元类对象 - %p %p&quot;,</span><br><span class="line">//          object_getClass(object_getClass(self.person1)), // self.person1.isa.isa</span><br><span class="line">//          object_getClass(object_getClass(self.person2))); // self.person2.isa.isa</span><br><span class="line"></span><br><span class="line">//Log查看方法</span><br><span class="line">persion1添加KVO监听之前2 - 0x1065687c0 0x1065687c0</span><br><span class="line">persion1添加KVO监听之后2 - 0x1069189e4 0x1065687c0</span><br><span class="line"></span><br><span class="line">p (IMP)0x1065687c0</span><br><span class="line">(IMP) $0 0x00... (Interview01`-[MJPerson setAge:] at MJPerson.m13)</span><br><span class="line"></span><br><span class="line">p (IMP)0x1069189e4</span><br><span class="line">(IMP) $1 0x00... (Foundation`_NSSetIntValueAndNotify)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类对象 - NSKVONotifying_MJPerson MJPersion</span><br><span class="line">元类对象 - NSKVONotifying_MJPerson MJPersion</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    // NSKVONotifying_MJPerson是使用Runtime动态创建的一个类，是MJPerson的子类</span><br><span class="line">    // self.person1.isa == NSKVONotifying_MJPerson</span><br><span class="line">    [self.person1 setAge:21];</span><br><span class="line">    </span><br><span class="line">    // self.person2.isa = MJPerson</span><br><span class="line">//    [self.person2 setAge:22];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.person1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当监听对象的属性值发生改变时，就会调用</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@属性值改变了 - %@ - %@&quot;, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/OC底层原理/imgs/3/3.3_1.png" alt></p>
<h2 id="3-4-NSSet-ValueAndNotify的内部实现"><a href="#3-4-NSSet-ValueAndNotify的内部实现" class="headerlink" title="3.4 _NSSet*ValueAndNotify的内部实现"></a>3.4 _NSSet*ValueAndNotify的内部实现</h2><p><img src="/2019/04/27/OC底层原理/imgs/3/3.4_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用willChangeValueForKey:</span><br><span class="line">调用原来的setter实现</span><br><span class="line">调用didChangeValueForKey:</span><br><span class="line">didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法</span><br></pre></td></tr></table></figure>
<h3 id="3-5-KVO子类的内部方法"><a href="#3-5-KVO子类的内部方法" class="headerlink" title="3.5 KVO子类的内部方法"></a>3.5 KVO子类的内部方法</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> 通过runtime获取方法类表。就知道有下面方法</span><br><span class="line"> - (void)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    // 获得方法数组</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 存储方法名</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的方法</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 获得方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 获得方法名</span><br><span class="line">        NSString *methodName = NSStringFromSelector(method_getName(method));</span><br><span class="line">        // 拼接方法名</span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot;, &quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放</span><br><span class="line">    free(methodList);</span><br><span class="line">    </span><br><span class="line">    // 打印方法名</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;, cls, methodNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> @implementation NSKVONotifying_MJPerson</span><br><span class="line"></span><br><span class="line">- (void)setAge:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    _NSSetIntValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 屏幕内部实现，隐藏了NSKVONotifying_MJPerson类的存在</span><br><span class="line">- (Class)class</span><br><span class="line">&#123;</span><br><span class="line">    return [MJPerson class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    // 收尾工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)_isKVOA</span><br><span class="line">&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li>iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类</span><br><span class="line">当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数</span><br><span class="line">willChangeValueForKey:</span><br><span class="line">父类原来的setter</span><br><span class="line">didChangeValueForKey:</span><br><span class="line">内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</span><br></pre></td></tr></table></figure>
<ul>
<li>如何手动触发KVO？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">手动调用willChangeValueForKey:和didChangeValueForKey:</span><br></pre></td></tr></table></figure>
<ul>
<li>直接修改成员变量会触发KVO么？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不会触发KVO</span><br></pre></td></tr></table></figure>
<h1 id="4、KVC"><a href="#4、KVC" class="headerlink" title="4、KVC"></a>4、KVC</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><blockquote>
<p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</p>
</blockquote>
<p>常见的API有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (id)valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-setValue-forKey-的原理"><a href="#4-2-setValue-forKey-的原理" class="headerlink" title="4.2 setValue:forKey:的原理"></a>4.2 setValue:forKey:的原理</h2><p><img src="/2019/04/27/OC底层原理/imgs/4/4.2_1.png" alt></p>
<ul>
<li>accessInstanceVariablesDirectly方法的默认返回值是YES</li>
</ul>
<h2 id="4-3-valueForKey-的原理"><a href="#4-3-valueForKey-的原理" class="headerlink" title="4.3 valueForKey:的原理"></a>4.3 valueForKey:的原理</h2><p><img src="/2019/04/27/OC底层原理/imgs/4/4.3_1.png" alt></p>
<h2 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h2><h3 id="通过KVC修改属性会触发KVO么？"><a href="#通过KVC修改属性会触发KVO么？" class="headerlink" title="通过KVC修改属性会触发KVO么？"></a>通过KVC修改属性会触发KVO么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过kvo监听某个属性，如果修改属性，会触发kvo，如果用 -&gt; 直接修改成员变量，不会触发KVO。</span><br><span class="line">如果通过kvc修改类的变量，不管是属性还是成员变量，只用通过kvo监听这个变量都很触发kvo。（即都很收到属性变化的通知）</span><br><span class="line">kvo监听某个属性，系统通过runtime生成NSKVONotififying_XXX子类重写set方法。发通知（见上面kvo原理）</span><br><span class="line">kvc在setValue:forKey/setValue:forKeyPath中调用willChangeValueForKey、didChangeValueForKey（必须成对出现，要不然不会发通知），在didChangeValueForKey中会发通知变量改变</span><br></pre></td></tr></table></figure>
<h3 id="KVC的赋值和取值过程是怎样的？原理是什么？"><a href="#KVC的赋值和取值过程是怎样的？原理是什么？" class="headerlink" title="KVC的赋值和取值过程是怎样的？原理是什么？"></a>KVC的赋值和取值过程是怎样的？原理是什么？</h3><h1 id="5、Category"><a href="#5、Category" class="headerlink" title="5、Category"></a>5、Category</h1><h2 id="5-1-Category的底层结构"><a href="#5-1-Category的底层结构" class="headerlink" title="5.1 Category的底层结构"></a>5.1 Category的底层结构</h2><p>定义在objc-runtime-new.h中</p>
<p><img src="/2019/04/27/OC底层原理/imgs/5/5.1_1.png" alt></p>
<h2 id="5-2-Category的加载处理过程"><a href="#5-2-Category的加载处理过程" class="headerlink" title="5.2 Category的加载处理过程"></a>5.2 Category的加载处理过程</h2><ol>
<li>通过Runtime加载某个类的所有Category数据</li>
<li>把所有Category的方法、属性、协议数据，合并到一个大数组中<br>后面参与编译的Category数据，会在数组的前面</li>
<li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面，多个分类最后面编译的分类添加在类原来数据的最前面。</li>
</ol>
<blockquote>
<p>注意：通过runtime在运行时将分类的方法合并到类对象和元类对象中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">源码解读顺序</span><br><span class="line">objc-os.mm</span><br><span class="line">_objc_init</span><br><span class="line">map_images</span><br><span class="line">map_images_nolock</span><br><span class="line"></span><br><span class="line">objc-runtime-new.mm</span><br><span class="line">_read_images</span><br><span class="line">remethodizeClass</span><br><span class="line">attachCategories</span><br><span class="line">attachLists</span><br><span class="line">realloc、memmove、 memcpy</span><br><span class="line"></span><br><span class="line">注意memmove、 memcpy</span><br><span class="line">将4567 0、1位置的数据移到1、2位置</span><br><span class="line"></span><br><span class="line">memmove流程：</span><br><span class="line">4567-&gt;4557-&gt;4457（现将1位置移到2位置，再将0位置移动到1位置，数据在同一块区域。会判断高低位，保证数据完整性）</span><br><span class="line">用于类中方法的移动。</span><br><span class="line"></span><br><span class="line">memcpy流程</span><br><span class="line">4567-&gt;4467-&gt;4447（现将0位置移到1位置，再将1位置移动到2位置，将分类中的信息追加到类中由于存放数据在不同的区域可以直接复制。）</span><br><span class="line">用于将分类中方法的移动到类中。</span><br></pre></td></tr></table></figure>
<p>原类添加分类原理图</p>
<p><img src="/2019/04/27/OC底层原理/imgs/5/5.2_1.png" alt></p>
<p>如果找到方法之后就不会继续往下找了，其他分类和原类中的同名方法还在，但是不会被执行。</p>
<ul>
<li>注意</li>
</ul>
<ol>
<li>原类和分类中有同名的方法，会执行分类中的。</li>
<li>原类中的同名方法还在，不会被执行。</li>
<li>一个类的多个分类有同名的方法，会按照编译顺序，执行最后编译的那个分类的方法。(即Build Phases-&gt;Compile Sources最下方的分类中的同名方法)<br>4. 类扩展（在.m头部写的私有属性，方法）是在编译的时候合并到类中，分类是通过runtime在运行时合并到类中。</li>
</ol>
<h2 id="5-3-load方法"><a href="#5-3-load方法" class="headerlink" title="5.3 +load方法"></a>5.3 +load方法</h2><ul>
<li>+load方法会在runtime加载类、分类时调用</li>
<li>每个类、分类的+load，在程序运行过程中只调用一次</li>
<li>调用顺序<ol>
<li>先调用类的+load<ol>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load（如果父类中的load已经调过，只调用一次，不会再调）</li>
</ol>
</li>
<li>再调用分类的+load<ol>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ol>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">objc4源码解读过程：</span><br><span class="line">objc-os.mm</span><br><span class="line">_objc_init</span><br><span class="line"></span><br><span class="line">load_images</span><br><span class="line"></span><br><span class="line">prepare_load_methods</span><br><span class="line">schedule_class_load</span><br><span class="line">add_class_to_loadable_list</span><br><span class="line">add_category_to_loadable_list</span><br><span class="line"></span><br><span class="line">call_load_methods</span><br><span class="line">call_class_loads</span><br><span class="line">call_category_loads</span><br><span class="line">(*load_method)(cls, SEL_load)</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    IMP method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    IMP mehtod;</span><br><span class="line">&#125;</span><br><span class="line">以上两个结构体中的method就是指向load方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用</li>
</ul>
<h2 id="5-4-initialize方法"><a href="#5-4-initialize方法" class="headerlink" title="5.4 +initialize方法"></a>5.4 +initialize方法</h2><ul>
<li>+initialize方法会在类第一次接收到消息时调用</li>
<li>调用顺序<ol>
<li>先调用父类的+initialize，再调用子类的+initialize</li>
<li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">objc4源码解读过程</span><br><span class="line">objc-msg-arm64.s</span><br><span class="line">objc_msgSend</span><br><span class="line"></span><br><span class="line">objc-runtime-new.mm</span><br><span class="line">class_getInstanceMethod</span><br><span class="line">lookUpImpOrNil</span><br><span class="line">lookUpImpOrForward</span><br><span class="line">_class_initialize</span><br><span class="line">callInitialize</span><br><span class="line">objc_msgSend(cls, SEL_initialize)</span><br><span class="line"></span><br><span class="line">伪代码</span><br><span class="line">if (自己没有初始化) &#123;</span><br><span class="line">    if (父类没有初始化) &#123;</span><br><span class="line">        objc_msgSend([父类 class], @selector(initialize));</span><br><span class="line">        父类初始化了;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_msgSend([自己 class], @selector(initialize));</span><br><span class="line">    自己初始化了;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点:<ul>
<li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）</li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li>
</ul>
</li>
</ul>
<h2 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、Category的实现原理"><a href="#1、Category的实现原理" class="headerlink" title="1、Category的实现原理"></a>1、Category的实现原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息。     </span><br><span class="line">在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</span><br></pre></td></tr></table></figure>
<h3 id="2、Category和Class-Extension的区别是什么？"><a href="#2、Category和Class-Extension的区别是什么？" class="headerlink" title="2、Category和Class Extension的区别是什么？"></a>2、Category和Class Extension的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class Extension在编译的时候，它的数据就已经包含在类信息中</span><br><span class="line">Category是在运行时，才会将数据合并到类信息中</span><br></pre></td></tr></table></figure>
<h3 id="3、Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？"><a href="#3、Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？" class="headerlink" title="3、Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？"></a>3、Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有load方法</span><br><span class="line">load方法在runtime加载类、分类的时候调用</span><br><span class="line">load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用(系统自己调用load方法是直接通过函数地址调用，如果手动调用load，即[Class load]，则通过消息发送机制调用load方法。先根据isa找到元类对象，如果有就调用，没有就通过superclass在父类中查找。)</span><br></pre></td></tr></table></figure>
<h3 id="4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？"><a href="#4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？" class="headerlink" title="4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？"></a>4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</h3><ul>
<li>load、initialize方法的区别是什么？<ul>
<li>调用方式<ul>
<li>load是根据函数地址直接调用</li>
<li>initialize是通过objc_msgSend调用</li>
</ul>
</li>
<li>调用时机<ul>
<li>load是runtime加载类、分类的时候调用（只会调用一次）</li>
<li>initialize是类第一次接收到消息的时候调用（在查找方法列表的时候，看类有没有初始化（先看父类有没有初始化，最后在看自己），没有初始化就发送initialize），每一个类只会调用一次，父类中的initialize方法可能会被调用多次。</li>
</ul>
</li>
</ul>
</li>
<li>load、initialize的调用顺序？<ul>
<li>load<ul>
<li>先调用类的load<ul>
<li>先编译的类，优先调用load</li>
<li>调用子类的load之前，会先调用父类的load</li>
</ul>
</li>
<li>再调用分类的load<ul>
<li>先编译的分类，优先调用load</li>
</ul>
</li>
</ul>
</li>
<li>initialize<ul>
<li>先初始化父类</li>
<li>再初始化子类（如果子类中没有实现initialize方法，调用父类中的initialize方法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="6、关联对象"><a href="#6、关联对象" class="headerlink" title="6、关联对象"></a>6、关联对象</h1><h2 id="6-1-如何实现给分类“添加成员变量”？"><a href="#6-1-如何实现给分类“添加成员变量”？" class="headerlink" title="6.1 如何实现给分类“添加成员变量”？"></a>6.1 如何实现给分类“添加成员变量”？</h2><p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现<br>关联对象提供了以下API:</p>
<ol>
<li>添加关联对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>获得关联对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void * key</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>移除所有的关联对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>
<h2 id="6-2-key的常见用"><a href="#6-2-key的常见用" class="headerlink" title="6.2 key的常见用"></a>6.2 key的常见用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static (const) void *MyKey = &amp;MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, MyKey)</span><br><span class="line"></span><br><span class="line">static (const) char MyKey;</span><br><span class="line">objc_setAssociatedObject(obj, &amp;MyKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, &amp;MyKey)</span><br><span class="line"></span><br><span class="line">使用属性名作为key（同一个常量地址相同）</span><br><span class="line">objc_setAssociatedObject(obj, @&quot;property&quot;, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(obj, @&quot;property&quot;);</span><br><span class="line"></span><br><span class="line">使用get方法的@selecor作为key（或者_cmd（和@selector(方法名)等效）</span><br><span class="line">objc_setAssociatedObject(obj, @selector(getter), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">objc_getAssociatedObject(obj, @selector(getter))</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">加static是为了让外部无法通过extern访问。static限制作用域。</span><br><span class="line">加const是为了和函数的参数类型一致，加不加都行。</span><br></pre></td></tr></table></figure>
<h2 id="6-3-objc-AssociationPolicy"><a href="#6-3-objc-AssociationPolicy" class="headerlink" title="6.3 objc_AssociationPolicy"></a>6.3 objc_AssociationPolicy</h2><p><img src="/2019/04/27/OC底层原理/imgs/6/6.3_1.png" alt></p>
<ul>
<li>注意：没有弱引用（weak）,弱引用相关用assign，如果访问已经释放了的对象，会造成崩溃（对象释放之后，weak会将指针置为nil，assign不会，会出现坏内存访问的崩溃）。</li>
<li>如果关联对象释放了，会将AssociationsHashMap中object对象对应的disguised_ptr_t和ObjectAssociationMap键值对移除。</li>
</ul>
<h2 id="6-4-关联对象的原理"><a href="#6-4-关联对象的原理" class="headerlink" title="6.4 关联对象的原理"></a>6.4 关联对象的原理</h2><p>实现关联对象技术的核心对象有</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
<p>objc4源码解读：objc-references.mm</p>
<p><img src="/2019/04/27/OC底层原理/imgs/6/6.4_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/6/6.4_2.png" alt></p>
<h1 id="7、Block"><a href="#7、Block" class="headerlink" title="7、Block"></a>7、Block</h1><h2 id="7-1-block的本质"><a href="#7-1-block的本质" class="headerlink" title="7.1 block的本质"></a>7.1 block的本质</h2><ul>
<li>block本质上也是一个OC对象，它内部也有个isa指针</li>
<li>是封装了函数调用以及函数调用环境的OC对象</li>
<li>block的底层结构如图所示</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.1_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">    NSLog(@&quot;this is a block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line">^&#123;</span><br><span class="line">    NSLog(@&quot;this is a block&quot;);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">将block赋值给一个变量</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;this is a block&quot;);</span><br><span class="line">&#125;</span><br><span class="line">执行</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<h2 id="7-2-block的变量捕获（capture）"><a href="#7-2-block的变量捕获（capture）" class="headerlink" title="7.2 block的变量捕获（capture）"></a>7.2 block的变量捕获（capture）</h2><ul>
<li><p>变量的分类</p>
<ul>
<li>局部变量<ul>
<li>auto</li>
<li>static</li>
<li>register</li>
</ul>
</li>
<li>全局变量</li>
</ul>
</li>
<li><p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制</p>
</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.2_1.png" alt></p>
<ul>
<li><p>局部变量block会捕获（由于局部变量作用域，可能访问的时候变量已经释放，所以需要在block中保存），全局变量block不会捕获。</p>
</li>
<li><p>block会捕获self。（self是oc方法的默认参数，是局部变量，oc代码转成c++代码，方法转成函数都会带两个默认参数：Class *self，SEL _cmd）</p>
</li>
<li><p>属性、成员变量block会捕获self，需要通过self才能访问到（属性：self.name，成员变量self-&gt;_name）</p>
</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.2_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">main.m中block的简化执行代码：</span><br><span class="line">// 定义block变量</span><br><span class="line">int a = 10;</span><br><span class="line">static b = 20;</span><br><span class="line">void (*block)(void) = &amp;__main_block_impl_0(</span><br><span class="line">                                            __main_block_func_0,</span><br><span class="line">                                            &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                            a,</span><br><span class="line">                                            &amp;b</span><br><span class="line">                                            );</span><br><span class="line"></span><br><span class="line">// 执行block内部的代码</span><br><span class="line">block-&gt;FuncPtr(block);</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">//结构体名称__main为调用block的方法名</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int a;</span><br><span class="line">  int *b;</span><br><span class="line">  // 构造函数（类似于OC的init方法），返回结构体对象</span><br><span class="line">  // a(_a) 将_a的值赋值给a</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc,  int _a, int *_b, int flags=0) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 封装了block执行逻辑的函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">            int a = __cself-&gt;a; </span><br><span class="line">            int *b = __cself-&gt;b;</span><br><span class="line">            </span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_fd2a14_mi_0, a, (*b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-block的类型"><a href="#7-3-block的类型" class="headerlink" title="7.3 block的类型"></a>7.3 block的类型</h2><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject(通过[block class],[[block class] superclass],[[[block class] superclass] superclass],[[[[block class] superclass] superclass] superclass]查看)</span><br><span class="line"></span><br><span class="line">block的类型以运行时为准，clang转的只能作为参考</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ）</li>
<li><strong>NSStackBlock</strong> （ _NSConcreteStackBlock ）</li>
<li><strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.3_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">越往下内存地址越大</span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">    int b = 20;</span><br><span class="line">    NSObject *o = [[NSObject allock] init];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;数据区域：a %p&quot;,&amp;a);</span><br><span class="line">    NSLog(@&quot;栈：b %p&quot;,&amp;b);</span><br><span class="line">    NSLog(@&quot;堆：o %p&quot;,o);</span><br><span class="line"></span><br><span class="line">    //打印类对象存放地址，看看和哪个区域接近，就可猜测存放位置</span><br><span class="line">    NSLog(@&quot;未知区域：x %p&quot;,[NSObject class]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.3_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ARC下block捕获auto变量仍是stackblock，会自动对block进行copy操作，要想观察block类型需要在MRC环境下。</span><br><span class="line">如果block是StackBlock，离开作用域block会被释放，再访问block会出现未知的错误。</span><br><span class="line">GlobalBlock、MallocBlock调用copy类型不变，StackBlock调用copy变成MallocBlock。</span><br><span class="line">MRC下对block进行copy，需要调用release释放block。</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    void(^block)(void) = [^&#123;</span><br><span class="line">        NSLog(@&quot;age is %d&quot;,age);</span><br><span class="line">    &#125; copy];</span><br><span class="line"></span><br><span class="line">    [block release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一种类型的block调用copy后的结果如下所示</p>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.3_3.png" alt></p>
<h2 id="7-4-block的copy"><a href="#7-4-block的copy" class="headerlink" title="7.4 block的copy"></a>7.4 block的copy</h2><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>
<ul>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ul>
<p>MRC下block属性的建议写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure></p>
<p>ARC下block属性的建议写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) void (^block)(void);</span><br><span class="line">@property (copy, nonatomic) void (^block)(void);</span><br></pre></td></tr></table></figure>
<h2 id="7-5-对象类型的auto变量"><a href="#7-5-对象类型的auto变量" class="headerlink" title="7.5 对象类型的auto变量"></a>7.5 对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时</p>
<ul>
<li>如果block是在栈上，将不会对auto变量产生强引用</li>
<li>如果block被拷贝到堆上<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会根据auto变量的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</li>
</ul>
</li>
<li>如果block从堆上移除<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的auto变量（release）</li>
</ul>
</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.5_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^MJBlock)(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MJBlock block;</span><br><span class="line">        &#123;</span><br><span class="line">            MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">            person.age = 10;</span><br><span class="line">            </span><br><span class="line">//            __weak MJPerson *weakPerson = person;</span><br><span class="line">            int age = 10;</span><br><span class="line">            block = ^&#123;</span><br><span class="line">                NSLog(@&quot;---------%d&quot;, person.age);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">转化成c++代码</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        MJBlock block;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            MJPerson *person = ((MJPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((MJPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;MJPerson&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">            ((void (*)(id, SEL, int))(void *)objc_msgSend)((id)person, sel_registerName(&quot;setAge:&quot;), 10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            int age = 10;</span><br><span class="line">            block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, 570425344));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c41e64_mi_1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  MJPerson *__strong person;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, MJPerson *__strong _person, int flags=0) : person(_person) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  MJPerson *__strong person = __cself-&gt;person; // bound by copy</span><br><span class="line"></span><br><span class="line">                NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_2r__m13fp2x2n9dvlr8d68yry500000gn_T_main_c41e64_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;age&quot;)));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-6-weak问题解决"><a href="#7-6-weak问题解决" class="headerlink" title="7.6 __weak问题解决"></a>7.6 __weak问题解决</h2><p>在使用clang转换OC为C++代码时，可能会遇到以下问题</p>
<blockquote>
<p>cannot create __weak reference in file using manual reference</p>
</blockquote>
<p>解决方案：支持ARC、指定运行时系统版本，比如</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</p>
</blockquote>
<h2 id="7-7-block修饰符"><a href="#7-7-block修饰符" class="headerlink" title="7.7 __block修饰符"></a>7.7 __block修饰符</h2><p><img src="/2019/04/27/OC底层原理/imgs/7/7.7_1.png" alt></p>
<ul>
<li>注意 只有在需要修改auto变量的时候再添加__block。尽量不要使用，加了之后编译的代码复杂。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^MJBlock)(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        __block int age = 10;</span><br><span class="line">        </span><br><span class="line">        MJBlock block = ^&#123;</span><br><span class="line">            age = 20;</span><br><span class="line">            NSLog(@&quot;age is %d&quot;, age);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        NSLog(@&quot;age的地址 %p&quot;,&amp;age);</span><br><span class="line">        __block int age底层转换成struct __Block_byref_age_0 age。</span><br><span class="line">        这个age的地址是struct __Block_byref_age_0中成员变量age的地址而不是，结构体的地址</span><br><span class="line">        隐藏的底层实现。</span><br><span class="line"></span><br><span class="line">        struct __main_block_impl_0 *blockImpl = (__bridge struct __main_block_impl_0 *)block;</span><br><span class="line"></span><br><span class="line">        p/x blockImpl-&gt;age</span><br><span class="line">        p/x blockImpl-&gt;age-&gt;age</span><br><span class="line">        （将block转成结构体，打印地址对比可知）</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">转成c++</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;</span><br><span class="line">            (void*)0,</span><br><span class="line">            (__Block_byref_age_0 *)&amp;age,</span><br><span class="line">             0, </span><br><span class="line">             sizeof(__Block_byref_age_0), </span><br><span class="line">             10</span><br><span class="line">             &#125;;</span><br><span class="line"></span><br><span class="line">        MJBlock block = ((void (*)())&amp;__main_block_impl_0(</span><br><span class="line">            (void *)__main_block_func_0, </span><br><span class="line">            &amp;__main_block_desc_0_DATA, </span><br><span class="line">            (__Block_byref_age_0 *)&amp;age, </span><br><span class="line">            570425344//flag</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</span><br><span class="line"></span><br><span class="line">            (age-&gt;__forwarding-&gt;age) = 20;</span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_wy_w7fw9cz93q584fpvsjv4g2z00000gn_T_main_43afa8_mi_0, (age-&gt;__forwarding-&gt;age));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-8-block的内存管理"><a href="#7-8-block的内存管理" class="headerlink" title="7.8 __block的内存管理"></a>7.8 __block的内存管理</h2><ul>
<li>当block在栈上时，并不会对__block变量产生强引用</li>
<li>当block被copy到堆时<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会对__block变量形成强引用（retain）</li>
</ul>
</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.8_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/7/7.8_2.png" alt></p>
<ul>
<li>当block从堆中移除时<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放引用的__block变量（release)<br><img src="/2019/04/27/OC底层原理/imgs/7/7.8_3.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/7/7.8_4.png" alt></li>
</ul>
</li>
</ul>
<h2 id="7-9-block的forwarding指针"><a href="#7-9-block的forwarding指针" class="headerlink" title="7.9 block的forwarding指针"></a>7.9 <strong>block的</strong>forwarding指针</h2><p>如果栈上的block进行copy会复制到堆上，同时将引用的<strong>block变量复制到堆上，</strong>forwarding指针，保证不管访问堆、栈哪个<strong>block变量，最终修改的都是堆上的</strong>block变量。</p>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.9_1.png" alt></p>
<h2 id="7-10-对象类型的auto变量、-block变量"><a href="#7-10-对象类型的auto变量、-block变量" class="headerlink" title="7.10 对象类型的auto变量、__block变量"></a>7.10 对象类型的auto变量、__block变量</h2><ul>
<li>当block在栈上时，对它们都不会产生强引用</li>
<li>当block拷贝到堆上时，都会通过copy函数来处理它们</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block变量（假设变量名叫做a）</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line"></span><br><span class="line">对象类型的auto变量（假设变量名叫做p）</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;p, (void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>
<ul>
<li>当block从堆上移除时，都会通过dispose函数来释放它们</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block变量（假设变量名叫做a）</span><br><span class="line">_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line"></span><br><span class="line">对象类型的auto变量（假设变量名叫做p）</span><br><span class="line">_Block_object_dispose((void*)src-&gt;p, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br></pre></td></tr></table></figure>
<ul>
<li>区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block在堆上</span><br><span class="line">对象类型的auto变量，会根据__strong/__weak _Block_object_assign决定是强引用还是弱引用。</span><br><span class="line">__block变量，_Block_object_assign都是强引用。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.10_1.png" alt></p>
<h2 id="7-11-被-block修饰的对象类型"><a href="#7-11-被-block修饰的对象类型" class="headerlink" title="7.11 被__block修饰的对象类型"></a>7.11 被__block修饰的对象类型</h2><ul>
<li>当__block变量在栈上时，不会对指向的对象产生强引用</li>
<li>当__block变量被copy到堆时<ul>
<li>会调用__block变量内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会根据所指向对象的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</li>
</ul>
</li>
<li>如果__block变量从堆上移除<ul>
<li>会调用__block变量内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放指向的对象（release）</li>
</ul>
</li>
</ul>
<h2 id="7-12-循环引用问题"><a href="#7-12-循环引用问题" class="headerlink" title="7.12 循环引用问题"></a>7.12 循环引用问题</h2><p><img src="/2019/04/27/OC底层原理/imgs/7/7.12_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    NSLog(@&quot;age is %d&quot;,strongSelf.age);</span><br><span class="line">&#125;</span><br><span class="line">加了__weak变量可能会在block调用之前已经释放，block内部是弱引用，可能无法访问到，需要用__strong保证weak变量在funcPtr未执行之前不会被释放。__strong也不是必须要加，如果weakself在block调用之前不会被释放，可以不加，加了也没问题。</span><br></pre></td></tr></table></figure>
<h3 id="7-12-1-解决循环引用问题-ARC"><a href="#7-12-1-解决循环引用问题-ARC" class="headerlink" title="7.12.1 解决循环引用问题 - ARC"></a>7.12.1 解决循环引用问题 - ARC</h3><ul>
<li>用<strong>weak、</strong>unsafe_unretained解决</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.12.1_1.png" alt></p>
<ul>
<li>用__block解决（必须要调用block）</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.12.1_2.png" alt></p>
<h3 id="7-12-2-解决循环引用问题-MRC"><a href="#7-12-2-解决循环引用问题-MRC" class="headerlink" title="7.12.2 解决循环引用问题 - MRC"></a>7.12.2 解决循环引用问题 - MRC</h3><ul>
<li>用__unsafe_unretained解决</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.12.2_1.png" alt></p>
<ul>
<li>用__block解决</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/7/7.12.2_2.png" alt></p>
<h2 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、block的原理是怎样的？本质是什么？"><a href="#1、block的原理是怎样的？本质是什么？" class="headerlink" title="1、block的原理是怎样的？本质是什么？"></a>1、block的原理是怎样的？本质是什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">封装了函数调用以及调用环境的OC对象</span><br></pre></td></tr></table></figure>
<h3 id="2、-block的作用是什么？有什么使用注意点？"><a href="#2、-block的作用是什么？有什么使用注意点？" class="headerlink" title="2、__block的作用是什么？有什么使用注意点？"></a>2、__block的作用是什么？有什么使用注意点？</h3><h3 id="3、block的属性修饰词为什么是copy？使用block有哪些使用注意？"><a href="#3、block的属性修饰词为什么是copy？使用block有哪些使用注意？" class="headerlink" title="3、block的属性修饰词为什么是copy？使用block有哪些使用注意？"></a>3、block的属性修饰词为什么是copy？使用block有哪些使用注意？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block一旦没有进行copy操作，就不会在堆上</span><br><span class="line">使用注意：循环引用问题</span><br></pre></td></tr></table></figure>
<h3 id="4、block在修改NSMutableArray，需不需要添加-block？"><a href="#4、block在修改NSMutableArray，需不需要添加-block？" class="headerlink" title="4、block在修改NSMutableArray，需不需要添加__block？"></a>4、block在修改NSMutableArray，需不需要添加__block？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block是为了解决无法修改auto变量的问题。如果在block内部只是使用arr，比如添加元素，是不需要添加__block的，如果是block内重新生成一个NSArray，并赋值给block之前的auto变量，这个auto变量需要添加__block。</span><br></pre></td></tr></table></figure>
<h1 id="8、Runtime"><a href="#8、Runtime" class="headerlink" title="8、Runtime"></a>8、Runtime</h1><ul>
<li>Objective-C是一门动态性比较强的编程语言，跟C、C++等语言有着很大的不同</li>
<li>Objective-C的动态性是由Runtime API来支撑的</li>
<li>Runtime API提供的接口基本都是C语言的，源码由C\C++\汇编语言编写</li>
</ul>
<h2 id="8-1-isa详解"><a href="#8-1-isa详解" class="headerlink" title="8.1 isa详解"></a>8.1 isa详解</h2><h3 id="8-1-1-isa简介"><a href="#8-1-1-isa简介" class="headerlink" title="8.1.1 isa简介"></a>8.1.1 isa简介</h3><ul>
<li>要想学习Runtime，首先要了解它底层的一些常用数据结构，比如isa指针</li>
<li>在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。需要用isa &amp; ISA_MASK才能找到类，元类。</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.1.1_1.png" alt></p>
<p>为了达到节省空间的目的，可以通过以下方式。</p>
<ul>
<li>用位运算，一个char可以存储8个bool变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">//@property (assign, nonatomic, getter=isTall) BOOL tall;</span><br><span class="line">//@property (assign, nonatomic, getter=isRich) BOOL rich;</span><br><span class="line">//@property (assign, nonatomic, getter=isHansome) BOOL handsome;</span><br><span class="line"></span><br><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// &amp;可以用来取出特定的位</span><br><span class="line"></span><br><span class="line">// 0000 0111</span><br><span class="line">//&amp;0000 0100</span><br><span class="line">//------</span><br><span class="line">// 0000 0100</span><br><span class="line"></span><br><span class="line">// 掩码，一般用来按位与(&amp;)运算的</span><br><span class="line">//#define MJTallMask 1</span><br><span class="line">//#define MJRichMask 2</span><br><span class="line">//#define MJHandsomeMask 4</span><br><span class="line"></span><br><span class="line">//#define MJTallMask 0b00000001</span><br><span class="line">//#define MJRichMask 0b00000010</span><br><span class="line">//#define MJHandsomeMask 0b00000100</span><br><span class="line"></span><br><span class="line">//用位移运算符优化的掩码</span><br><span class="line">#define MJTallMask (1&lt;&lt;0)</span><br><span class="line">#define MJRichMask (1&lt;&lt;1)</span><br><span class="line">#define MJHandsomeMask (1&lt;&lt;2)</span><br><span class="line"></span><br><span class="line">@interface MJPerson()</span><br><span class="line">&#123;</span><br><span class="line">    char _tallRichHansome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 0010 1010</span><br><span class="line">//&amp;1111 1101</span><br><span class="line">//----------</span><br><span class="line">// 0010 1000</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _tallRichHansome = 0b00000100;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTall:(BOOL)tall</span><br><span class="line">&#123;</span><br><span class="line">    if (tall) &#123;</span><br><span class="line">        //如果某位想设置为1只需要将该位|1，这位设置成1。</span><br><span class="line">        _tallRichHansome |= MJTallMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果某位想设置为0只需要将该位&amp;0，这位设置成0。~为按位取反。</span><br><span class="line">        _tallRichHansome &amp;= ~MJTallMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">把用的那一位用 &amp;1 取出</span><br><span class="line">只要&amp;出有值，肯定不为0</span><br><span class="line">!(_tallRichHansome &amp; MJTallMask)将char转成bool，取反。</span><br><span class="line">!！(_tallRichHansome &amp; MJTallMask)为转换成相应的bool值。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHansome &amp; MJTallMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)rich</span><br><span class="line">&#123;</span><br><span class="line">    if (rich) &#123;</span><br><span class="line">        _tallRichHansome |= MJRichMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHansome &amp;= ~MJRichMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isRich</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHansome &amp; MJRichMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHandsome:(BOOL)handsome</span><br><span class="line">&#123;</span><br><span class="line">    if (handsome) &#123;</span><br><span class="line">        _tallRichHansome |= MJHandsomeMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHansome &amp;= ~MJHandsomeMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHandsome</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHansome &amp; MJHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>位域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MJPerson()</span><br><span class="line">&#123;</span><br><span class="line">    // 位域</span><br><span class="line">    struct &#123;</span><br><span class="line">        char tall : 1;</span><br><span class="line">        char rich : 1;</span><br><span class="line">        char handsome : 1;</span><br><span class="line">    &#125; _tallRichHandsome;</span><br><span class="line">    /* </span><br><span class="line">    0b00000000 tall为右边第一位，rich为右边第二位，handsome为右边第三位。</span><br><span class="line">    char tall : 2;</span><br><span class="line">    char rich : 2;</span><br><span class="line">    char handsome : 2;</span><br><span class="line">    如果都改成2，则isTall可改为</span><br><span class="line">    - (BOOL)isTall</span><br><span class="line">    &#123;</span><br><span class="line">        return _tallRichHandsome.tall;</span><br><span class="line">    &#125;</span><br><span class="line">    如果 char tall : 1;像上面那样写，会将最后一位填充到前面变成0b1111 1111 为-1。char tall : 2；两位表示bool 用0b01的高位0填充变成 0b0000 0001为yes。</span><br><span class="line">    **/</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">- (void)setTall:(BOOL)tall</span><br><span class="line">&#123;</span><br><span class="line">    _tallRichHandsome.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall</span><br><span class="line">&#123;</span><br><span class="line">    //将char转成bool</span><br><span class="line">    return !!_tallRichHandsome.tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)rich</span><br><span class="line">&#123;</span><br><span class="line">    _tallRichHandsome.rich = rich;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isRich</span><br><span class="line">&#123;</span><br><span class="line">    return !!_tallRichHandsome.rich;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHandsome:(BOOL)handsome</span><br><span class="line">&#123;</span><br><span class="line">    _tallRichHandsome.handsome = handsome;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHandsome</span><br><span class="line">&#123;</span><br><span class="line">    return !!_tallRichHandsome.handsome;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">      MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">        person.rich = YES;</span><br><span class="line">        person.tall = NO;</span><br><span class="line">        person.handsome = NO;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;tall:%d rich:%d hansome:%d&quot;, person.isTall, person.isRich, person.isHandsome);</span><br><span class="line">&#125;</span><br><span class="line">lldb</span><br><span class="line">p/x persion-&gt;_tallRichHandsome</span><br><span class="line">p/x &amp;(persion-&gt;_tallRichHandsome)</span><br><span class="line">x 上面的地址</span><br><span class="line"></span><br><span class="line">* 共用体</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface MJPerson : NSObject</span><br><span class="line">- (void)setTall:(BOOL)tall;</span><br><span class="line">- (void)setRich:(BOOL)rich;</span><br><span class="line">- (void)setHandsome:(BOOL)handsome;</span><br><span class="line">- (void)setThin:(BOOL)thin;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall;</span><br><span class="line">- (BOOL)isRich;</span><br><span class="line">- (BOOL)isHandsome;</span><br><span class="line">- (BOOL)isThin;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJPerson.h&quot;</span><br><span class="line"></span><br><span class="line">#define MJTallMask (1&lt;&lt;0)</span><br><span class="line">#define MJRichMask (1&lt;&lt;1)</span><br><span class="line">#define MJHandsomeMask (1&lt;&lt;2)</span><br><span class="line">#define MJThinMask (1&lt;&lt;3)</span><br><span class="line"></span><br><span class="line">@interface MJPerson()</span><br><span class="line">&#123;</span><br><span class="line">    //共用体，共用一块内存。（bits和_tallRichHandsome共用一块内存）</span><br><span class="line">    union &#123;</span><br><span class="line">        char bits;</span><br><span class="line">        //和第一种方式相同。结构体只是为了增加代码的可读性，可以删除。</span><br><span class="line">        //如果结构体的大小大于8bit，则bits需要改为更长的类型，如int。以免越界丢失</span><br><span class="line">        struct &#123;</span><br><span class="line">            char tall : 1;</span><br><span class="line">            char rich : 1;</span><br><span class="line">            char handsome : 1;</span><br><span class="line">            char thin : 1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; _tallRichHandsome;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">- (void)setTall:(BOOL)tall</span><br><span class="line">&#123;</span><br><span class="line">    if (tall) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJTallMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJTallMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isTall</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHandsome.bits &amp; MJTallMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setRich:(BOOL)rich</span><br><span class="line">&#123;</span><br><span class="line">    if (rich) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJRichMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJRichMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isRich</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHandsome.bits &amp; MJRichMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setHandsome:(BOOL)handsome</span><br><span class="line">&#123;</span><br><span class="line">    if (handsome) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJHandsomeMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJHandsomeMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isHandsome</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHandsome.bits &amp; MJHandsomeMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setThin:(BOOL)thin</span><br><span class="line">&#123;</span><br><span class="line">    if (thin) &#123;</span><br><span class="line">        _tallRichHandsome.bits |= MJThinMask;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _tallRichHandsome.bits &amp;= ~MJThinMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isThin</span><br><span class="line">&#123;</span><br><span class="line">    return !!(_tallRichHandsome.bits &amp; MJThinMask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">* 相关技术点，NS_OPTIONS枚举实现原理</span><br></pre></td></tr></table></figure>
<p>typedef enum {<br>    MJOptionsOne = 1 &lt;&lt; 0,<br>    MJOptionsTwo = 1 &lt;&lt; 1,<br>    MJOptionsThree = 1 &lt;&lt; 2,<br>    MJOptionsFour = 1 &lt;&lt; 3,<br>} MJOptions;</p>
<ul>
<li><p>(int)main {<br>  [self setOptions:MJOptionsOne | MJOptionsTwo | MJOptionsThree | MJOptionsFour];<br>}</p>
</li>
<li><p>(void)setOptions:(MJOptions)options {<br>  if (options &amp; MJOptionsOne) {</p>
<pre><code>NSLog(@&quot;包含MJOptionsOne&quot;);
</code></pre><p>  }<br>  if (options &amp; MJOptionsTwo) {</p>
<pre><code>NSLog(@&quot;包含MJOptionsTwo&quot;);
</code></pre><p>  }<br>  if (options &amp; MJOptionsThree) {</p>
<pre><code>NSLog(@&quot;包含MJOptionsThree&quot;);
</code></pre><p>  }<br>  if (options &amp; MJOptionsFour) {</p>
<pre><code>NSLog(@&quot;包含MJOptionsFour&quot;);
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-1-2-isa位域"><a href="#8-1-2-isa位域" class="headerlink" title="8.1.2 isa位域"></a>8.1.2 isa位域</h3><p>p/x obj-&gt;isa可以查看每一位</p>
<ul>
<li>nonpointer<ul>
<li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li>has_assoc<ul>
<li>是否有设置过关联对象，如果没有，释放时会更快，如果有需要先移除关联对象。（objc-runtime-new.mm中objc_destructInstance函数中有源码）</li>
</ul>
</li>
<li>has_cxx_dtor<ul>
<li>是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快，如果有，需要先调用析构函数。（objc-runtime-new.mm中objc_destructInstance函数中有源码）</li>
</ul>
</li>
<li>shiftcls<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
<li>Class、Meta-Class对象的内存地址值最后三位永远是0（shiftcls右边有上面三位的信息，&amp;ISA_MASK后三位为0，使用位域，先用的是最右边的位）</li>
</ul>
</li>
<li>magic<ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li>weakly_referenced<ul>
<li>是否有被弱引用指向过，如果没有，释放时会更快</li>
</ul>
</li>
<li>deallocating<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li>extra_rc<ul>
<li>里面存储的值是引用计数器减1</li>
</ul>
</li>
<li>has_sidetable_rc<ul>
<li>引用计数器是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li>
</ul>
</li>
</ul>
<h2 id="8-2-Class"><a href="#8-2-Class" class="headerlink" title="8.2 Class"></a>8.2 Class</h2><h3 id="8-2-1-Class的结构"><a href="#8-2-1-Class的结构" class="headerlink" title="8.2.1 Class的结构"></a>8.2.1 Class的结构</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.1_1.png" alt></p>
<p><a href="project/MJClassInfo.h">MJClassInfo.h</a></p>
<ul>
<li>bits和isa相似，存储了很多信息。</li>
<li>MJClassInfo为了方便理解进行了简化，methods等是一维数组，真实类型为下面的二维数组。</li>
</ul>
<h3 id="8-2-2-class-rw-t"><a href="#8-2-2-class-rw-t" class="headerlink" title="8.2.2 class_rw_t"></a>8.2.2 class_rw_t</h3><ul>
<li>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。可以动态添加分类。</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.2_1.png" alt></p>
<h3 id="8-2-3-class-ro-t"><a href="#8-2-3-class-ro-t" class="headerlink" title="8.2.3 class_ro_t"></a>8.2.3 class_ro_t</h3><ul>
<li>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.3_1.png" alt></p>
<h3 id="8-2-4-method-t"><a href="#8-2-4-method-t" class="headerlink" title="8.2.4 method_t"></a>8.2.4 method_t</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.4_1.png" alt></p>
<h3 id="8-2-5-Type-Encoding"><a href="#8-2-5-Type-Encoding" class="headerlink" title="8.2.5 Type Encoding"></a>8.2.5 Type Encoding</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.5_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%s&quot;, @encode(int));//输出 i 表示int</span><br><span class="line">NSLog(@&quot;%s&quot;, @encode(id));//输出 @ 表示 an obj or id type</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> &quot;i24@0:8i16f20&quot;</span><br><span class="line"> &quot;i 24 @ 0 : 8 i 16 f 20&quot;</span><br><span class="line"> i表示返回类型int，24 所有参数是字节数，@表示self，0表示重0开始，:表示参数 _cmd，8表示起始位置，i表示age的参数类型int，16表示起始位置，f表示height的参数类型float，20表示起始位置。</span><br><span class="line"> **/</span><br><span class="line">- (int)test:(int)age height:(float)height;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-6-方法缓存"><a href="#8-2-6-方法缓存" class="headerlink" title="8.2.6 方法缓存"></a>8.2.6 方法缓存</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.2.6_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/8/8.2.6_2.png" alt></p>
<ul>
<li>@selector(selName) &amp; _mask &lt;= _mask,所以_mask为散列表的长度-1，（下标从0开始）</li>
<li>算法详情见MJClassInfo.h中cache_t结构体的方法 IMP imp(SEL selector)中的实现。如果一直没有找到合适的index。会将_buckets清空，将_mask翻倍，重新进行缓存计算。</li>
<li>通过MJClassInfo.h查看Cache_t</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">MJClassInfo.h为c++代码。使用步骤</span><br><span class="line">1、将MJClassInfo.h添加到工程中。</span><br><span class="line">2、将用到的类的.m修改成.mm。（为了支持c++语法）</span><br><span class="line">3、强制转换类型</span><br><span class="line">MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">mj_objc_class *personClass = (__bridge mj_objc_class *)[MJPerson class];</span><br><span class="line">[person test1];</span><br><span class="line">[person test2];</span><br><span class="line">[person test3];</span><br><span class="line">[person test4];</span><br><span class="line">4、打断点，每调用一个方法，查看personClass结构。cache数组只能显示第一个位置的信息，有可能为空。计算出来的index可能不是第0个位置。</span><br><span class="line">如果想查看cache数据的所有数据。</span><br><span class="line">bucket_t *buckets = cache._buckets;</span><br><span class="line"></span><br><span class="line">//bucket_t bucket = buckets[(long long)@selector(studentTest) &amp; cache._mask];</span><br><span class="line">//NSLog(@&quot;%s %p&quot;, bucket._key, bucket._imp);</span><br><span class="line">//有可能第一次算出来的index不是我们想取的方法。调用MJClassInfo.h中cache_t结构体的方法 IMP imp(SEL selector)能保证取出来的index是想要的。</span><br><span class="line">        </span><br><span class="line">for (int i = 0; i &lt;= cache._mask; i++) &#123;</span><br><span class="line">    bucket_t bucket = buckets[i];</span><br><span class="line">    NSLog(@&quot;%s %p&quot;, bucket._key, bucket._imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lldb</span><br><span class="line">//可以查看方法。</span><br><span class="line">p (IMP)(上面log出来的imp地址)</span><br><span class="line">(lldb)p (IMP)0x100000e00 </span><br><span class="line">(IMP) $0 = 0x100000e00 (Interview01-cache`-[MJPerson personTest] at MJPerson.m:12)</span><br><span class="line">//Interview01-cache为工程名，-[MJPerson personTest] at MJPerson.m:12，方法位置。</span><br></pre></td></tr></table></figure>
<h2 id="8-3-objc-msgSend"><a href="#8-3-objc-msgSend" class="headerlink" title="8.3 objc_msgSend"></a>8.3 objc_msgSend</h2><blockquote>
<p>sel_registerName(“test”)等价于@selector(test)<br>c语言转汇编会在方法名称前加一个_</p>
</blockquote>
<h3 id="8-3-1-执行流程"><a href="#8-3-1-执行流程" class="headerlink" title="8.3.1 执行流程"></a>8.3.1 执行流程</h3><ul>
<li>OC中的方法调用，其实都是转换为objc_msgSend函数的调用</li>
<li>objc_msgSend的执行流程可以分为3大阶段<ul>
<li>消息发送</li>
<li>动态方法解析</li>
<li>消息转发</li>
</ul>
</li>
</ul>
<h3 id="8-3-2-源码跟读"><a href="#8-3-2-源码跟读" class="headerlink" title="8.3.2 源码跟读"></a>8.3.2 源码跟读</h3><ul>
<li><p>objc-msg-arm64.s</p>
<ul>
<li>ENTRY _objc_msgSend</li>
<li>b.le    LNilOrTagged</li>
<li>CacheLookup NORMAL</li>
<li>.macro CacheLookup</li>
<li>.macro CheckMiss</li>
<li>STATIC_ENTRY __objc_msgSend_uncached</li>
<li>.macro MethodTableLookup</li>
<li>__class_lookupMethodAndLoadCache3</li>
</ul>
</li>
<li><p>objc-runtime-new.mm</p>
<ul>
<li>_class_lookupMethodAndLoadCache3</li>
<li>lookUpImpOrForward</li>
<li>getMethodNoSuper_nolock、search_method_list、log_and_fill_cache</li>
<li>cache_getImp、log_and_fill_cache、getMethodNoSuper_nolock、log_and_fill_cache</li>
<li>_class_resolveInstanceMethod</li>
<li>_objc_msgForward_impcache</li>
</ul>
</li>
<li><p>objc-msg-arm64.s</p>
<ul>
<li>STATIC_ENTRY __objc_msgForward_impcache</li>
<li>ENTRY __objc_msgForward</li>
</ul>
</li>
<li><p>Core Foundation</p>
<ul>
<li>__forwarding__（不开源）</li>
</ul>
</li>
</ul>
<h3 id="8-3-3-消息发送"><a href="#8-3-3-消息发送" class="headerlink" title="8.3.3 消息发送"></a>8.3.3 消息发送</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.3.3_1.png" alt></p>
<h3 id="8-3-4-动态方法解析"><a href="#8-3-4-动态方法解析" class="headerlink" title="8.3.4 动态方法解析"></a>8.3.4 动态方法解析</h3><p><img src="/2019/04/27/OC底层原理/imgs/8/8.3.4_1.png" alt></p>
<ul>
<li>动态添加方法</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.3.4_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">//- (void)test;</span><br><span class="line">+ (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJPerson.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">//void c_other(id self, SEL _cmd)</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;c_other - %@ - %@&quot;, self, NSStringFromSelector(_cmd));</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">//&#123;</span><br><span class="line">//    if (sel == @selector(test)) &#123;</span><br><span class="line">//        // 第一个参数是object_getClass(self)</span><br><span class="line">//        class_addMethod(object_getClass(self), sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class="line">//        return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super resolveClassMethod:sel];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">//&#123;</span><br><span class="line">//    if (sel == @selector(test)) &#123;</span><br><span class="line">//        // 动态添加test方法的实现</span><br><span class="line">//        class_addMethod(self, sel, (IMP)c_other, &quot;v16@0:8&quot;);</span><br><span class="line">//</span><br><span class="line">//        // 返回YES代表有动态添加方法</span><br><span class="line">//        return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super resolveInstanceMethod:sel];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//- (void)other</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">//&#123;</span><br><span class="line">//    if (sel == @selector(test)) &#123;</span><br><span class="line">//        // 获取其他方法</span><br><span class="line">//        Method method = class_getInstanceMethod(self, @selector(other));</span><br><span class="line">//</span><br><span class="line">//        // 动态添加test方法的实现</span><br><span class="line">//        class_addMethod(self, sel,</span><br><span class="line">//                        method_getImplementation(method),</span><br><span class="line">//                        method_getTypeEncoding(method));</span><br><span class="line">//</span><br><span class="line">//        // 返回YES代表有动态添加方法</span><br><span class="line">//        return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super resolveInstanceMethod:sel];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// typedef struct objc_method *Method;</span><br><span class="line">// struct objc_method == struct method_t</span><br><span class="line">//        struct method_t *otherMethod = (struct method_t *)class_getInstanceMethod(self, @selector(other));</span><br><span class="line"></span><br><span class="line">struct method_t &#123;</span><br><span class="line">    SEL sel;</span><br><span class="line">    char *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">//&#123;</span><br><span class="line">//    if (sel == @selector(test)) &#123;</span><br><span class="line">//        // 获取其他方法</span><br><span class="line">//        struct method_t *method = (struct method_t *)class_getInstanceMethod(self, @selector(other));</span><br><span class="line">//</span><br><span class="line">//        // 动态添加test方法的实现</span><br><span class="line">//        class_addMethod(self, sel, method-&gt;imp, method-&gt;types);</span><br><span class="line">//</span><br><span class="line">//        // 返回YES代表有动态添加方法</span><br><span class="line">//        return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super resolveInstanceMethod:sel];</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-5-消息转发"><a href="#8-3-5-消息转发" class="headerlink" title="8.3.5 消息转发"></a>8.3.5 消息转发</h3><p>来到消息转发会调用函数__forwarding__，内部会调用下图中的方法，__forwarding__未开源，国外根据汇编写的伪代码如下<br>原版<br><a href="project/__forwarding__.c">__forwarding__.c</a><br>删除部分逻辑的精简版<br><a href="project/__forwarding__clean.c">__forwarding__clean.c</a></p>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.3.5_1.png" alt></p>
<ul>
<li>生成NSMethodSignature</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/8/8.3.5_2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">#import &quot;MJPerson.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">//- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">//&#123;</span><br><span class="line">//    if (aSelector == @selector(test)) &#123;</span><br><span class="line">//        // objc_msgSend([[MJCat alloc] init], aSelector)</span><br><span class="line">//        return [[MJCat alloc] init];</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// 方法签名：返回值类型、参数类型</span><br><span class="line">//- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">//&#123;</span><br><span class="line">//    if (aSelector == @selector(test)) &#123;</span><br><span class="line">//        return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">//    &#125;</span><br><span class="line">//    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span><br><span class="line">//    anInvocation.target 方法调用者</span><br><span class="line">//    anInvocation.selector 方法名</span><br><span class="line">//    [anInvocation getArgument:NULL atIndex:0]</span><br><span class="line">//- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">//&#123;</span><br><span class="line">////    anInvocation.target = [[MJCat alloc] init];</span><br><span class="line">////    [anInvocation invoke];</span><br><span class="line">//</span><br><span class="line">//    [anInvocation invokeWithTarget:[[MJCat alloc] init]];</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MJCat : NSObject</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJCat</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">- (int)test:(int)age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if (aSelector == @selector(test:)) &#123;</span><br><span class="line">//        return [NSMethodSignature signatureWithObjCTypes:&quot;v20@0:8i16&quot;];</span><br><span class="line">//省略大小，直接写类型</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;i@:i&quot;];</span><br><span class="line">//        return [[[MJCat alloc] init] methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果能来到forwardInvocation，里面想干什么就干什么，比如只是NSLog，而不对anInvocation进行处理。调用的方法就是forwardInvocation中写的东西。</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    // 参数顺序：receiver、selector、other arguments</span><br><span class="line">//    int age;</span><br><span class="line">//    [anInvocation getArgument:&amp;age atIndex:2];</span><br><span class="line">//    NSLog(@&quot;%d&quot;, age + 10);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // anInvocation.target == [[MJCat alloc] init]</span><br><span class="line">    // anInvocation.selector == test:</span><br><span class="line">    // anInvocation的参数：15</span><br><span class="line">    // [[[MJCat alloc] init] test:15]</span><br><span class="line">    </span><br><span class="line">    [anInvocation invokeWithTarget:[[MJCat alloc] init]];</span><br><span class="line">    </span><br><span class="line">    int ret;</span><br><span class="line">    [anInvocation getReturnValue:&amp;ret];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface MJCat : NSObject</span><br><span class="line">- (int)test:(int)age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJCat</span><br><span class="line">- (int)test:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    return age * 2;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">        [person test:15];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">+ (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //objc_msgSend看receiver是什么类型，所以这里+、-方法都可以调。</span><br><span class="line">    //if (aSelector == @selector(test)) return [MJCat class];</span><br><span class="line">    // objc_msgSend([[MJCat alloc] init], @selector(test))</span><br><span class="line">    // [[[MJCat alloc] init] test]</span><br><span class="line">    if (aSelector == @selector(test)) return [[MJCat alloc] init];</span><br><span class="line"></span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">//&#123;</span><br><span class="line">//    if (aSelector == @selector(test)) return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">//    </span><br><span class="line">//    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//+ (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">//&#123;</span><br><span class="line">//    NSLog(@&quot;1123&quot;);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MJCat : NSObject</span><br><span class="line">+ (void)test;</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJCat.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJCat</span><br><span class="line"></span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 消息转发：将消息转发给别人</span><br><span class="line">// 元类对象是一种特殊的类对象</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [MJPerson test];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">- (void)run;</span><br><span class="line">- (void)test;</span><br><span class="line">- (void)other;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJPerson.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MJPerson</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;run-123&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    // 本来能调用的方法</span><br><span class="line">    if ([self respondsToSelector:aSelector]) &#123;</span><br><span class="line">        return [super methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 找不到的方法</span><br><span class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 找不到的方法，都会来到这里</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;找不到%@方法&quot;, NSStringFromSelector(anInvocation.selector));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// NSProxy</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">        //处理MJPerson未实现的方法</span><br><span class="line">        [person run];</span><br><span class="line">        [person test];</span><br><span class="line">        [person other];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-super"><a href="#8-4-super" class="headerlink" title="8.4 super"></a>8.4 super</h2><h3 id="8-4-1-super的本质"><a href="#8-4-1-super的本质" class="headerlink" title="8.4.1 super的本质"></a>8.4.1 super的本质</h3><ul>
<li>super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数<ul>
<li>struct objc_super2</li>
<li>SEL</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super2 &#123;</span><br><span class="line">    id receiver;</span><br><span class="line">    Class current_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过汇编可以看到，和clang转的c++代码objc_msgSendSuper有区别<br>objc_megSendSuper({self, class_getSuperclass(objc_getClass(“MJStudent”))}, sel_registerName(“class”))<br>objc_msgSendSuper2的第一个参数结构体是将当前类传进去，内部找到superclass</p>
</blockquote>
<ul>
<li>receiver是消息接收者</li>
<li>current_class是receiver的Class对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">MJStudent继承于MJPerson</span><br><span class="line">NSLog(@&quot;[self class] = %@&quot;, [self class]); // MJStudent</span><br><span class="line">NSLog(@&quot;[self superclass] = %@&quot;, [self superclass]); // MJPerson</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;--------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">objc_megSendSuper(&#123;self, class_getSuperclass(objc_getClass(&quot;MJStudent&quot;))&#125;, sel_registerName(&quot;class&quot;))</span><br><span class="line">// objc_msgSendSuper(&#123;self, [MJPerson class]&#125;, @selector(class));</span><br><span class="line">class在NSObject中，class的底层实现</span><br><span class="line">@implementation NSObject</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">所以NSLog(@&quot;[super class] = %@&quot;, [super class]); 输出 MJStudent</span><br><span class="line">[super message]的底层实现</span><br><span class="line">1.消息接收者仍然是子类对象</span><br><span class="line">2.从父类开始查找方法的实现</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">*/</span><br><span class="line">NSLog(@&quot;[super class] = %@&quot;, [super class]); // MJStudent</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br><span class="line">**/</span><br><span class="line">NSLog(@&quot;[super superclass] = %@&quot;, [super superclass]); // MJPerson</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">//@implementation NSObject</span><br><span class="line">//</span><br><span class="line">//- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">//    return [self class] == cls;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">//    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">//        if (tcls == cls) return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return NO;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">//    return object_getClass((id)self) == cls;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">//    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">//        if (tcls == cls) return YES;</span><br><span class="line">//    &#125;</span><br><span class="line">//    return NO;</span><br><span class="line">//&#125;</span><br><span class="line">//@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [[NSObject class] isKindOfClass:[NSObject class]]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [[NSObject class] isMemberOfClass:[NSObject class]]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [[MJPerson class] isKindOfClass:[MJPerson class]]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [[MJPerson class] isMemberOfClass:[MJPerson class]]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 这句代码的方法调用者不管是哪个类（只要是NSObject体系下的），都返回YES</span><br><span class="line">        NSLog(@&quot;%d&quot;, [NSObject isKindOfClass:[NSObject class]]); // 1</span><br><span class="line">        NSLog(@&quot;%d&quot;, [NSObject isMemberOfClass:[NSObject class]]); // 0</span><br><span class="line">        NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[MJPerson class]]); // 0</span><br><span class="line">        NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:[MJPerson class]]); // 0</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">//        id person = [[MJPerson alloc] init];</span><br><span class="line">        </span><br><span class="line">//        NSLog(@&quot;%d&quot;, [person isMemberOfClass:[MJPerson class]]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [person isMemberOfClass:[NSObject class]]);</span><br><span class="line">        </span><br><span class="line">//        NSLog(@&quot;%d&quot;, [person isKindOfClass:[MJPerson class]]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [person isKindOfClass:[NSObject class]]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">//        NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:object_getClass([MJPerson class])]);</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:object_getClass([NSObject class])]);</span><br><span class="line">        </span><br><span class="line">        //基类的元类对象的supperclass就是基类</span><br><span class="line">//        NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[NSObject class]]);//1 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>isKindOfClass、isMemberOfClass左边是实例对象，右边需要传类对象；左边是类对象，右边需要传元类对象。用以比较类对象和元类对象。<br>特殊情况：<br>下面这句代码的方法调用者不管是哪个类（只要是NSObject体系下的），都返回YES<br>[NSObject isKindOfClass:[NSObject class]]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@interface MJPerson : NSObject</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;MJPerson.h&quot;</span><br><span class="line">@implementation MJPerson</span><br><span class="line">- (void)print &#123;</span><br><span class="line">    NSLog(@&quot;my name is %@&quot;, self-&gt;_name);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ViewController.m中的方法</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">//    NSString *test = @&quot;123&quot;;</span><br><span class="line"></span><br><span class="line">     //以下编译会报错么？打印结果是什么？</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">     1. 没有初始化实例对象，print为什么能够调用成功？</span><br><span class="line">     2. 为什么print方法中的self.name变成了ViewController等其他内容。（打印结果和viewDidLoad方法前面的内容有关）</span><br><span class="line">     3. 和通过实例对象调用方法有什么相同和区别。</span><br><span class="line">     */</span><br><span class="line">    id cls = [MJPerson class];</span><br><span class="line">    void *obj = &amp;cls;</span><br><span class="line">    [(__bridge id)obj print];</span><br><span class="line">    //obj-&gt;cls-&gt;[MJPerson class];</span><br><span class="line"></span><br><span class="line">    MJPerson *person = [[MJPerson alloc] init];</span><br><span class="line">    [person print];</span><br><span class="line">    //person-&gt;person实例变量的isa指针（实例变量是一个结构体，第一个成员变量isa,第二个成员变量_name，实例变量的地址和isa指针的地址相同。）-&gt;[MJPerson class]，上面的cls和isa很像，都指向[MJPerson class]</span><br><span class="line"></span><br><span class="line">    // 局部变量分配在栈空间</span><br><span class="line">    // 栈空间分配，从高地址到低地址</span><br><span class="line">    //*</span><br><span class="line">      void test() &#123;</span><br><span class="line">          long long a = 4; // 0x7ffee638bff8</span><br><span class="line">          long long b = 5; // 0x7ffee638bff0</span><br><span class="line">          long long c = 6; // 0x7ffee638bfe8</span><br><span class="line">          long long d = 7; // 0x7ffee638bfe0</span><br><span class="line">          </span><br><span class="line">          NSLog(@&quot;%p %p %p %p&quot;, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">      &#125;</span><br><span class="line">    **/</span><br><span class="line"></span><br><span class="line">//    struct MJPerson_IMPL</span><br><span class="line">//    &#123;</span><br><span class="line">//        Class isa;</span><br><span class="line">//        NSString *_name;</span><br><span class="line">//    &#125;;</span><br><span class="line">    print方法中self.name是通过指向的地址内存忽略前八个字节找到_name地址。</span><br><span class="line">    self.name中的其实是obj-&gt;name。obj的地址+8，找到的是test变量的地址。如果[super viewDidLoad]下面没有添加局部变量，打印my name is &lt;ViewController: 0x...&gt;</span><br><span class="line"></span><br><span class="line">    分析：</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    转成：</span><br><span class="line">   struct abc = &#123;</span><br><span class="line">       self,</span><br><span class="line">       [ViewController class]</span><br><span class="line">       &#125;;</span><br><span class="line">       //查看xcode汇编代码发现super 转成 objc_msgSendSuper2</span><br><span class="line">    objc_msgSendSuper2(abc, @selector(viewDidLoad));</span><br><span class="line">    有一个影藏的局部变量，struct abc，</span><br><span class="line">    self.name-&gt; obj-&gt;_name -&gt; abc中的self</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">//    long long *p = (long long *)obj;</span><br><span class="line">//    NSLog(@&quot;%p %p&quot;, *(p+2), [ViewController class]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-LLVM的中间代码（IR）"><a href="#8-4-2-LLVM的中间代码（IR）" class="headerlink" title="8.4.2 LLVM的中间代码（IR）"></a>8.4.2 LLVM的中间代码（IR）</h3><ul>
<li><p>Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）</p>
</li>
<li><p>可以使用以下命令行指令生成中间代码</p>
<ul>
<li>clang -emit-llvm -S main.m</li>
</ul>
</li>
<li><p>语法简介</p>
<ul>
<li>@ - 全局变量</li>
<li>% - 局部变量</li>
<li>alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存</li>
<li>i32 - 32位4字节的整数</li>
<li>align - 对齐</li>
<li>load - 读出，store 写入</li>
<li>icmp - 两个整数值比较，返回布尔值</li>
<li>br - 选择分支，根据条件来转向label，不根据条件跳转的话类似 goto</li>
<li>label - 代码标签</li>
<li>call - 调用函数</li>
</ul>
</li>
<li><p>具体可以参考官方文档：<a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">llvm</a></p>
</li>
</ul>
<h2 id="8-5-Runtime的应用"><a href="#8-5-Runtime的应用" class="headerlink" title="8.5 Runtime的应用"></a>8.5 Runtime的应用</h2><ul>
<li>查看私有成员变量<ul>
<li>设置UITextField占位文字的颜色</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.textField.text = @&quot;请输入用户名&quot;;</span><br><span class="line">[self.textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字典转模型</p>
<ul>
<li>利用Runtime遍历所有的属性或者成员变量</li>
<li>利用KVC设值</li>
</ul>
</li>
<li><p>替换方法实现</p>
<ul>
<li>class_replaceMethod</li>
<li>method_exchangeImplementations</li>
</ul>
</li>
</ul>
<h2 id="8-6-Runtime-API"><a href="#8-6-Runtime-API" class="headerlink" title="8.6 Runtime API"></a>8.6 Runtime API</h2><h3 id="8-6-1-类"><a href="#8-6-1-类" class="headerlink" title="8.6.1 类"></a>8.6.1 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">动态创建一个类（参数：父类，类名，额外的内存空间）</span><br><span class="line">Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</span><br><span class="line"></span><br><span class="line">注册一个类（要在类注册之前添加成员变量）</span><br><span class="line">void objc_registerClassPair(Class cls) </span><br><span class="line"></span><br><span class="line">销毁一个类</span><br><span class="line">void objc_disposeClassPair(Class cls)</span><br><span class="line"></span><br><span class="line">获取isa指向的Class</span><br><span class="line">Class object_getClass(id obj)</span><br><span class="line"></span><br><span class="line">设置isa指向的Class</span><br><span class="line">Class object_setClass(id obj, Class cls)</span><br><span class="line"></span><br><span class="line">判断一个OC对象是否为Class</span><br><span class="line">BOOL object_isClass(id obj)</span><br><span class="line"></span><br><span class="line">判断一个Class是否为元类</span><br><span class="line">BOOL class_isMetaClass(Class cls)</span><br><span class="line"></span><br><span class="line">获取父类</span><br><span class="line">Class class_getSuperclass(Class cls)</span><br></pre></td></tr></table></figure>
<h3 id="8-6-2-成员变量"><a href="#8-6-2-成员变量" class="headerlink" title="8.6.2 成员变量"></a>8.6.2 成员变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">获取一个实例变量信息</span><br><span class="line">Ivar class_getInstanceVariable(Class cls, const char *name)</span><br><span class="line"></span><br><span class="line">拷贝实例变量列表（最后需要调用free释放）</span><br><span class="line">Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</span><br><span class="line"></span><br><span class="line">设置和获取成员变量的值</span><br><span class="line">void object_setIvar(id obj, Ivar ivar, id value)</span><br><span class="line">id object_getIvar(id obj, Ivar ivar)</span><br><span class="line"></span><br><span class="line">动态添加成员变量（已经注册的类是不能动态添加成员变量的）</span><br><span class="line">BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</span><br><span class="line"></span><br><span class="line">获取成员变量的相关信息</span><br><span class="line">const char *ivar_getName(Ivar v)</span><br><span class="line">const char *ivar_getTypeEncoding(Ivar v)</span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-属性"><a href="#8-6-3-属性" class="headerlink" title="8.6.3 属性"></a>8.6.3 属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">获取一个属性</span><br><span class="line">objc_property_t class_getProperty(Class cls, const char *name)</span><br><span class="line"></span><br><span class="line">拷贝属性列表（最后需要调用free释放）</span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line"></span><br><span class="line">动态添加属性</span><br><span class="line">BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,</span><br><span class="line">                  unsigned int attributeCount)</span><br><span class="line"></span><br><span class="line">动态替换属性</span><br><span class="line">void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,</span><br><span class="line">                      unsigned int attributeCount)</span><br><span class="line"></span><br><span class="line">获取属性的一些信息</span><br><span class="line">const char *property_getName(objc_property_t property)</span><br><span class="line">const char *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure>
<h3 id="8-6-4-方法"><a href="#8-6-4-方法" class="headerlink" title="8.6.4 方法"></a>8.6.4 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">获得一个实例方法、类方法</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)</span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)</span><br><span class="line"></span><br><span class="line">方法实现相关操作</span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name) </span><br><span class="line">IMP method_setImplementation(Method m, IMP imp)</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2) </span><br><span class="line"></span><br><span class="line">拷贝方法列表（最后需要调用free释放）</span><br><span class="line">Method *class_copyMethodList(Class cls, unsigned int *outCount)</span><br><span class="line"></span><br><span class="line">动态添加方法</span><br><span class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line"></span><br><span class="line">动态替换方法</span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line"></span><br><span class="line">获取方法的相关信息（带有copy的需要调用free去释放）</span><br><span class="line">SEL method_getName(Method m)</span><br><span class="line">IMP method_getImplementation(Method m)</span><br><span class="line">const char *method_getTypeEncoding(Method m)</span><br><span class="line">unsigned int method_getNumberOfArguments(Method m)</span><br><span class="line">char *method_copyReturnType(Method m)</span><br><span class="line">char *method_copyArgumentType(Method m, unsigned int index)</span><br><span class="line"></span><br><span class="line">选择器相关</span><br><span class="line">const char *sel_getName(SEL sel)</span><br><span class="line">SEL sel_registerName(const char *str)</span><br><span class="line"></span><br><span class="line">用block作为方法实现</span><br><span class="line">IMP imp_implementationWithBlock(id block)</span><br><span class="line">id imp_getBlock(IMP anImp)</span><br><span class="line">BOOL imp_removeBlock(IMP anImp)</span><br></pre></td></tr></table></figure>
<h2 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、讲一下-OC-的消息机制"><a href="#1、讲一下-OC-的消息机制" class="headerlink" title="1、讲一下 OC 的消息机制"></a>1、讲一下 OC 的消息机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</span><br><span class="line">objc_msgSend底层有3大阶段</span><br><span class="line">消息发送（当前类、父类中查找）、动态方法解析、消息转发</span><br></pre></td></tr></table></figure>
<h3 id="2、消息转发机制流程"><a href="#2、消息转发机制流程" class="headerlink" title="2、消息转发机制流程"></a>2、消息转发机制流程</h3><h3 id="3、消息转发机制流程"><a href="#3、消息转发机制流程" class="headerlink" title="3、消息转发机制流程"></a>3、消息转发机制流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</span><br><span class="line">OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</span><br><span class="line">平时编写的OC代码，底层都是转换成了Runtime API进行调用</span><br><span class="line"></span><br><span class="line">具体应用</span><br><span class="line">利用关联对象（AssociatedObject）给分类添加属性</span><br><span class="line">遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</span><br><span class="line">交换方法实现（交换系统的方法）</span><br><span class="line">利用消息转发机制解决方法找不到的异常问题</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h1 id="9、RunLoop"><a href="#9、RunLoop" class="headerlink" title="9、RunLoop"></a>9、RunLoop</h1><h2 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h2><h3 id="9-1-1-什么是RunLoop"><a href="#9-1-1-什么是RunLoop" class="headerlink" title="9.1.1 什么是RunLoop"></a>9.1.1 什么是RunLoop</h3><ul>
<li>顾名思义<ul>
<li>运行循环</li>
<li>在程序运行过程中循环做一些事情</li>
</ul>
</li>
<li>应用范畴<ul>
<li>定时器（Timer）、PerformSelector</li>
<li>GCD Async Main Queue</li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li>AutoreleasePool</li>
</ul>
</li>
</ul>
<h3 id="9-1-2-如果没有RunLoop"><a href="#9-1-2-如果没有RunLoop" class="headerlink" title="9.1.2 如果没有RunLoop"></a>9.1.2 如果没有RunLoop</h3><p><img src="/2019/04/27/OC底层原理/imgs/9/9.1.2_1.png" alt></p>
<ul>
<li>执行完第13行代码后，会即将退出程序</li>
</ul>
<h3 id="9-1-3-如果有了RunLoop"><a href="#9-1-3-如果有了RunLoop" class="headerlink" title="9.1.3 如果有了RunLoop"></a>9.1.3 如果有了RunLoop</h3><p><img src="/2019/04/27/OC底层原理/imgs/9/9.1.3_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/9/9.1.3_2.png" alt></p>
<p>程序并不会马上退出，而是保持运行状态</p>
<ul>
<li>RunLoop的基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="9-2-RunLoop对象"><a href="#9-2-RunLoop对象" class="headerlink" title="9.2 RunLoop对象"></a>9.2 RunLoop对象</h2><ul>
<li><p>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation：NSRunLoop</li>
<li>Core Foundation：CFRunLoopRef</li>
</ul>
</li>
<li><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象</p>
<ul>
<li>NSRunLoop是基于CFRunLoopRef的一层OC包装</li>
<li>CFRunLoopRef是开源的。<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef</a></li>
</ul>
</li>
</ul>
<h3 id="9-2-1-RunLoop与线程"><a href="#9-2-1-RunLoop与线程" class="headerlink" title="9.2.1 RunLoop与线程"></a>9.2.1 RunLoop与线程</h3><ul>
<li><p>每条线程都有唯一的一个与之对应的RunLoop对象</p>
</li>
<li><p>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</p>
</li>
<li><p>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建（调用[NSRunLoop CurrentRunLoop]或者CFRunLoopGetCurrent()）</p>
</li>
<li><p>RunLoop会在线程结束时销毁</p>
</li>
<li><p>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</p>
</li>
</ul>
<h3 id="9-2-2-获取RunLoop对象"><a href="#9-2-2-获取RunLoop对象" class="headerlink" title="9.2.2 获取RunLoop对象"></a>9.2.2 获取RunLoop对象</h3><ul>
<li><p>Foundation</p>
<ul>
<li>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</li>
<li>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</li>
</ul>
</li>
<li><p>Core Foundation</p>
<ul>
<li>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</li>
<li>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</li>
</ul>
</li>
</ul>
<h2 id="9-3-Mode"><a href="#9-3-Mode" class="headerlink" title="9.3 Mode"></a>9.3 Mode</h2><h3 id="9-3-1-RunLoop相关的类"><a href="#9-3-1-RunLoop相关的类" class="headerlink" title="9.3.1 RunLoop相关的类"></a>9.3.1 RunLoop相关的类</h3><p><img src="/2019/04/27/OC底层原理/imgs/9/9.3.1_1.png" alt></p>
<blockquote>
<p>_commonModes放的是NSRunLoopCommonModes表示的modes即NSDefaultRunLoopMode、UITrackingRunLoopMode两个，当模式为commonModes就去_commonModes查找。_commonModelItems为标记为NSRunLoopCommonModes的对象。</p>
</blockquote>
<h3 id="9-3-2-CFRunLoopModeRef"><a href="#9-3-2-CFRunLoopModeRef" class="headerlink" title="9.3.2 CFRunLoopModeRef"></a>9.3.2 CFRunLoopModeRef</h3><ul>
<li><p>CFRunLoopModeRef代表RunLoop的运行模式</p>
</li>
<li><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</p>
</li>
<li><p>RunLoop启动时只能选择其中一个Mode，作为currentMode</p>
</li>
<li><p>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</p>
<ul>
<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>
</ul>
</li>
<li><p>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</p>
</li>
<li><p>常见的2种Mode</p>
<ul>
<li><p>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行</p>
</li>
<li><p>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>lldb命令 bt可以打印隐藏的函数调用栈。</p>
</blockquote>
<h3 id="9-3-3-CFRunLoopObserverRef"><a href="#9-3-3-CFRunLoopObserverRef" class="headerlink" title="9.3.3 CFRunLoopObserverRef"></a>9.3.3 CFRunLoopObserverRef</h3><p><img src="/2019/04/27/OC底层原理/imgs/9/9.3.3_1.png" alt></p>
<h3 id="9-3-4-添加Observer监听RunLoop的所有状态"><a href="#9-3-4-添加Observer监听RunLoop的所有状态" class="headerlink" title="9.3.4 添加Observer监听RunLoop的所有状态"></a>9.3.4 添加Observer监听RunLoop的所有状态</h3><p><img src="/2019/04/27/OC底层原理/imgs/9/9.3.4_1.png" alt></p>
<h2 id="9-4-RunLoop的运行逻辑"><a href="#9-4-RunLoop的运行逻辑" class="headerlink" title="9.4 RunLoop的运行逻辑"></a>9.4 RunLoop的运行逻辑</h2><p><img src="/2019/04/27/OC底层原理/imgs/9/9.4_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/9/9.4_2.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/9/9.4_3.png" alt></p>
<ul>
<li>04中的block  CFRunLoopPerformBlock(<code>CFRunLoopRef rl</code>,<code>CFTypeRef mode</code>,<code>^(void)block</code>)</li>
<li>新建一个Single View App项目。在ViewController添加touchBegin方法，在方法中添加一个断点，运行点击屏幕，来到断点。lldb中执行bt命名，就可以看到被xcode影藏的详细调用栈，找到runloop入口函数CFRunLoopRunSpecific，然后去上面的runloop源码中搜索。</li>
<li><p>07休眠，通过mach_msg调用内核api让当前线程休眠，不做任何事情。while(1)虽然也阻塞线程，但是线程一直在循环执行，没有真正的休眠。</p>
</li>
<li><p>休眠原理<br><img src="/2019/04/27/OC底层原理/imgs/9/9.4_4.png" alt></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">在ViewController上添加一个UITextView，并滑动UITextView</span><br><span class="line">...</span><br><span class="line">switch(activity) &#123;</span><br><span class="line">    case kcfRunLoopEntry: &#123;</span><br><span class="line">        CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">        NSLog(@&quot;kCFRunLoopEntry - %@&quot;,mode);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case kCFRunLoopExit: &#123;</span><br><span class="line">        CFRunLoopMode mode = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent());</span><br><span class="line">        NSLog(@&quot;kCFRunLoopExit - %@&quot;,mode);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">观察UITextView=滚动过程mode切换。滚动时为UITrackingRunLoopMode，停止滚动为kCFRunLoopDefaultMode</span><br></pre></td></tr></table></figure>
<h2 id="9-5-RunLoop在实际开中的应用"><a href="#9-5-RunLoop在实际开中的应用" class="headerlink" title="9.5 RunLoop在实际开中的应用"></a>9.5 RunLoop在实际开中的应用</h2><ul>
<li>控制线程生命周期（线程保活）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@interface MJThread : NSThread</span><br><span class="line">@end</span><br><span class="line">#import &quot;MJThread.h&quot;</span><br><span class="line">@implementation MJThread</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;MJThread.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (strong, nonatomic) MJThread *thread;</span><br><span class="line">@property (assign, nonatomic, getter=isStoped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    self.stopped = NO;</span><br><span class="line">    self.thread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----begin----&quot;, [NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        // 往RunLoop里面添加Source\Timer\Observer</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        while (!weakSelf.isStoped) &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@----end----&quot;, [NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        // NSRunLoop的run方法是无法停止的，它专门用于开启一个永不销毁的线程（NSRunLoop）</span><br><span class="line">        //        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">        /*</span><br><span class="line">         it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:.</span><br><span class="line">         In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)stop &#123;</span><br><span class="line">    // 在子线程调用stop</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">    //waitUntilDone=NO不会等待子线程执行完直接返回。点击返回按钮，控制器销毁，delloc中调用stop，不等stopThread执行就直接结束stop，控制器销毁，然后执行stopThread中的方法，因为控制器已经销毁，会出现坏内存访问的崩溃。需要将这个参数改为YES。等子线程中的执行完，delloc才能执行完，在释放控制器。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于停止子线程的RunLoop</span><br><span class="line">- (void)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    // 设置标记为NO</span><br><span class="line">    self.stopped = YES;</span><br><span class="line">    </span><br><span class="line">    // 停止RunLoop</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>解决NSTimer在滑动时停止工作的问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int count = 0;</span><br><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;, ++count);</span><br><span class="line">&#125;];</span><br><span class="line">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">//    [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span><br><span class="line">    </span><br><span class="line">// NSDefaultRunLoopMode、UITrackingRunLoopMode才是真正存在的模式</span><br><span class="line">// NSRunLoopCommonModes并不是一个真的模式，它只是一个标记</span><br><span class="line">// timer能在_commonModes数组中存放的模式下工作</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<ul>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
<h2 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、讲讲-RunLoop，项目中有用到吗？"><a href="#1、讲讲-RunLoop，项目中有用到吗？" class="headerlink" title="1、讲讲 RunLoop，项目中有用到吗？"></a>1、讲讲 RunLoop，项目中有用到吗？</h3><h3 id="2、runloop内部实现逻辑？"><a href="#2、runloop内部实现逻辑？" class="headerlink" title="2、runloop内部实现逻辑？"></a>2、runloop内部实现逻辑？</h3><h3 id="3、runloop和线程的关系？"><a href="#3、runloop和线程的关系？" class="headerlink" title="3、runloop和线程的关系？"></a>3、runloop和线程的关系？</h3><h3 id="4、timer-与-runloop-的关系？"><a href="#4、timer-与-runloop-的关系？" class="headerlink" title="4、timer 与 runloop 的关系？"></a>4、timer 与 runloop 的关系？</h3><h3 id="5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"><a href="#5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？" class="headerlink" title="5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"></a>5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h3><h3 id="6、runloop-是怎么响应用户操作的，-具体流程是什么样的？"><a href="#6、runloop-是怎么响应用户操作的，-具体流程是什么样的？" class="headerlink" title="6、runloop 是怎么响应用户操作的， 具体流程是什么样的？"></a>6、runloop 是怎么响应用户操作的， 具体流程是什么样的？</h3><h3 id="7、说说runLoop的几种状态"><a href="#7、说说runLoop的几种状态" class="headerlink" title="7、说说runLoop的几种状态"></a>7、说说runLoop的几种状态</h3><h3 id="8、runloop的mode作用是什么？"><a href="#8、runloop的mode作用是什么？" class="headerlink" title="8、runloop的mode作用是什么？"></a>8、runloop的mode作用是什么？</h3><h1 id="10、多线程"><a href="#10、多线程" class="headerlink" title="10、多线程"></a>10、多线程</h1><h2 id="10-1-方案"><a href="#10-1-方案" class="headerlink" title="10.1 方案"></a>10.1 方案</h2><h3 id="10-1-1-iOS中的常见多线程方案"><a href="#10-1-1-iOS中的常见多线程方案" class="headerlink" title="10.1.1 iOS中的常见多线程方案"></a>10.1.1 iOS中的常见多线程方案</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.1.1_1.png" alt></p>
<h3 id="10-1-2-GCD的常用函数"><a href="#10-1-2-GCD的常用函数" class="headerlink" title="10.1.2 GCD的常用函数"></a>10.1.2 GCD的常用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GCD中有2个用来执行任务的函数</span><br><span class="line">用同步的方式执行任务</span><br><span class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class="line">queue：队列</span><br><span class="line">block：任务</span><br><span class="line"></span><br><span class="line">用异步的方式执行任务</span><br><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">GCD源码</a></p>
<h3 id="10-1-3-GCD的队列"><a href="#10-1-3-GCD的队列" class="headerlink" title="10.1.3 GCD的队列"></a>10.1.3 GCD的队列</h3><ul>
<li><p>GCD的队列可以分为2大类型</p>
<ul>
<li><p>并发队列（Concurrent Dispatch Queue）</p>
<ul>
<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>
<li>并发功能只有在异步（dispatch_async）函数下才有效</li>
</ul>
</li>
<li><p>串行队列（Serial Dispatch Queue）</p>
<ul>
<li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-1-4-容易混淆的术语"><a href="#10-1-4-容易混淆的术语" class="headerlink" title="10.1.4 容易混淆的术语"></a>10.1.4 容易混淆的术语</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.1.4_1.png" alt></p>
<h3 id="10-1-5-各种队列的执行效果"><a href="#10-1-5-各种队列的执行效果" class="headerlink" title="10.1.5 各种队列的执行效果"></a>10.1.5 各种队列的执行效果</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.1.5_1.png" alt></p>
<h2 id="10-2-队列组的使用"><a href="#10-2-队列组的使用" class="headerlink" title="10.2 队列组的使用"></a>10.2 队列组的使用</h2><ul>
<li>思考：如何用gcd实现以下功能<ul>
<li>异步并发执行任务1、任务2</li>
<li>等任务1、任务2都执行完毕后，再回到主线程执行任务3</li>
</ul>
</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.2_1.png" alt></p>
<h2 id="10-3-线程同步"><a href="#10-3-线程同步" class="headerlink" title="10.3 线程同步"></a>10.3 线程同步</h2><h3 id="10-3-1-多线程的安全隐患"><a href="#10-3-1-多线程的安全隐患" class="headerlink" title="10.3.1 多线程的安全隐患"></a>10.3.1 多线程的安全隐患</h3><ul>
<li>资源共享<ul>
<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>
<li>比如多个线程访问同一个对象、同一个变量、同一个文件</li>
</ul>
</li>
<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>
</ul>
<h3 id="10-3-2-存钱取钱"><a href="#10-3-2-存钱取钱" class="headerlink" title="10.3.2 存钱取钱"></a>10.3.2 存钱取钱</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.3.2_1.png" alt></p>
<h3 id="10-3-3-卖票"><a href="#10-3-3-卖票" class="headerlink" title="10.3.3 卖票"></a>10.3.3 卖票</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.3.3_1.png" alt></p>
<h3 id="10-3-4-多线程安全隐患分析"><a href="#10-3-4-多线程安全隐患分析" class="headerlink" title="10.3.4 多线程安全隐患分析"></a>10.3.4 多线程安全隐患分析</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.3.4_1.png" alt></p>
<h3 id="10-3-5-多线程安全隐患的解决方案"><a href="#10-3-5-多线程安全隐患的解决方案" class="headerlink" title="10.3.5 多线程安全隐患的解决方案"></a>10.3.5 多线程安全隐患的解决方案</h3><ul>
<li>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）</li>
<li>常见的线程同步技术是：加锁</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.3.5_1.png" alt></p>
<h2 id="10-4-线程同步方案"><a href="#10-4-线程同步方案" class="headerlink" title="10.4 线程同步方案"></a>10.4 线程同步方案</h2><h3 id="10-4-1-iOS中的线程同步方案"><a href="#10-4-1-iOS中的线程同步方案" class="headerlink" title="10.4.1 iOS中的线程同步方案"></a>10.4.1 iOS中的线程同步方案</h3><ul>
<li>OSSpinLock</li>
<li>os_unfair_lock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ul>
<h3 id="10-4-2-GNUstep"><a href="#10-4-2-GNUstep" class="headerlink" title="10.4.2 GNUstep"></a>10.4.2 GNUstep</h3><ul>
<li>GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍</li>
<li><a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">源码地址</a></li>
<li>虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</li>
</ul>
<h3 id="10-4-3-OSSpinLock"><a href="#10-4-3-OSSpinLock" class="headerlink" title="10.4.3 OSSpinLock"></a>10.4.3 OSSpinLock</h3><ul>
<li>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</li>
<li>目前已经不再安全，可能会出现优先级反转问题<ul>
<li>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</li>
<li>需要导入头文件#import &lt;libkern/OSAtomic.h&gt;</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过时间片轮转调度算法，让每个线程/进程，执行固定时间（如10ms）后切换，实现多线程。使用自旋锁，低优先级的线程，先加锁执行一段时间，切换线程，有高优先级的线程执行已经加锁需要忙等，cpu会让高优先级的线程多执行一会，或者先执行完，低优先级的线程一直没法执行完，释放锁，高优先级线程一直处于忙等状态。</p>
</blockquote>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.3_1.png" alt></p>
<h3 id="10-4-4-os-unfair-lock"><a href="#10-4-4-os-unfair-lock" class="headerlink" title="10.4.4 os_unfair_lock"></a>10.4.4 os_unfair_lock</h3><ul>
<li>os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持</li>
<li>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</li>
<li>需要导入头文件#import &lt;os/lock.h&gt;</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.4_1.png" alt></p>
<h3 id="10-4-5-pthread-mutex"><a href="#10-4-5-pthread-mutex" class="headerlink" title="10.4.5 pthread_mutex"></a>10.4.5 pthread_mutex</h3><ul>
<li>mutex叫做”互斥锁”，等待锁的线程会处于休眠状态</li>
<li>需要导入头文件#import &lt;pthread.h&gt;</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.5_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/10/10.4.5_2.png" alt></p>
<ul>
<li>递归锁</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.5_3.png" alt></p>
<blockquote>
<p>递归锁：允许同一个线程对一把锁进行重复加锁</p>
</blockquote>
<ul>
<li>条件</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.5_4.png" alt></p>
<blockquote>
<p>对应生产者-消费者模型，只有先生产出东西，才能消费</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过查看汇编代码，就可以知道互斥锁、自旋锁的实现原理</span><br><span class="line">stepi/si 单行执行一条汇编，遇到方法调用会跳进去。</span><br><span class="line">nexti/ni 单行执行一条汇编，遇到方法调用会跳过。</span><br><span class="line">c 执行到断点</span><br><span class="line"></span><br><span class="line">自旋锁，汇编代码一直循环调用。</span><br><span class="line">互斥锁，线程休眠</span><br></pre></td></tr></table></figure>
<h3 id="10-4-6-NSLock、NSRecursiveLock"><a href="#10-4-6-NSLock、NSRecursiveLock" class="headerlink" title="10.4.6 NSLock、NSRecursiveLock"></a>10.4.6 NSLock、NSRecursiveLock</h3><p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.6_1.png" alt></p>
<h3 id="10-4-7-NSCondition"><a href="#10-4-7-NSCondition" class="headerlink" title="10.4.7 NSCondition"></a>10.4.7 NSCondition</h3><ul>
<li>NSCondition是对mutex和cond的封装</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.7_1.png" alt></p>
<h3 id="10-4-8-NSConditionLock"><a href="#10-4-8-NSConditionLock" class="headerlink" title="10.4.8 NSConditionLock"></a>10.4.8 NSConditionLock</h3><ul>
<li>NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.8_1.png" alt></p>
<h3 id="10-4-9-dispatch-semaphore"><a href="#10-4-9-dispatch-semaphore" class="headerlink" title="10.4.9 dispatch_semaphore"></a>10.4.9 dispatch_semaphore</h3><ul>
<li>semaphore叫做”信号量”</li>
<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>
<li>信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.9_1.png" alt></p>
<h3 id="10-4-10-dispatch-queue"><a href="#10-4-10-dispatch-queue" class="headerlink" title="10.4.10 dispatch_queue"></a>10.4.10 dispatch_queue</h3><ul>
<li>直接使用GCD的串行队列，也是可以实现线程同步的</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.4.10_1.png" alt></p>
<h3 id="10-4-11-synchronized"><a href="#10-4-11-synchronized" class="headerlink" title="10.4.11 @synchronized"></a>10.4.11 @synchronized</h3><ul>
<li>@synchronized是对mutex递归锁的封装</li>
<li>源码查看：objc4中的objc-sync.mm文件</li>
<li>@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized(obj) &#123;</span><br><span class="line">    //任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="10-4-12-iOS线程同步方案性能比较"><a href="#10-4-12-iOS线程同步方案性能比较" class="headerlink" title="10.4.12 iOS线程同步方案性能比较"></a>10.4.12 iOS线程同步方案性能比较</h3><ul>
<li>性能从高到低排序<ul>
<li>os_unfair_lock</li>
<li>OSSpinLock</li>
<li>dispatch_semaphore</li>
<li>pthread_mutex</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSCondition</li>
<li>pthread_mutex(recursive)</li>
<li>NSRecursiveLock</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ul>
</li>
</ul>
<h3 id="10-4-13-自旋锁、互斥锁比较"><a href="#10-4-13-自旋锁、互斥锁比较" class="headerlink" title="10.4.13 自旋锁、互斥锁比较"></a>10.4.13 自旋锁、互斥锁比较</h3><ul>
<li><p>什么情况使用自旋锁比较划算？</p>
<ul>
<li>预计线程等待锁的时间很短</li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>
<li>CPU资源不紧张</li>
<li>多核处理器</li>
</ul>
</li>
<li><p>什么情况使用互斥锁比较划算？</p>
<ul>
<li>预计线程等待锁的时间较长</li>
<li>单核处理器</li>
<li>临界区有IO操作</li>
<li>临界区代码复杂或者循环量大</li>
<li>临界区竞争非常激烈</li>
</ul>
</li>
</ul>
<h2 id="10-5-atomic"><a href="#10-5-atomic" class="headerlink" title="10.5 atomic"></a>10.5 atomic</h2><p>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁</p>
<p>可以参考源码objc4的objc-accessors.mm  </p>
<p>它并不能保证使用属性的过程是线程安全的</p>
<h2 id="10-6-读写安全"><a href="#10-6-读写安全" class="headerlink" title="10.6 读写安全"></a>10.6 读写安全</h2><h3 id="10-6-1-iOS中的读写安全方案"><a href="#10-6-1-iOS中的读写安全方案" class="headerlink" title="10.6.1 iOS中的读写安全方案"></a>10.6.1 iOS中的读写安全方案</h3><ul>
<li><p>思考如何实现以下场景</p>
<ul>
<li>同一时间，只能有1个线程进行写的操作</li>
<li>同一时间，允许有多个线程进行读的操作</li>
<li>同一时间，不允许既有写的操作，又有读的操作</li>
</ul>
</li>
<li><p>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作，iOS中的实现方案有</p>
<ul>
<li>pthread_rwlock：读写锁</li>
<li>dispatch_barrier_async：异步栅栏调用</li>
</ul>
</li>
</ul>
<h3 id="10-6-2-pthread-rwlock"><a href="#10-6-2-pthread-rwlock" class="headerlink" title="10.6.2 pthread_rwlock"></a>10.6.2 pthread_rwlock</h3><ul>
<li>等待锁的线程会进入休眠</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.6.2_1.png" alt></p>
<h3 id="10-6-3-dispatch-barrier-async"><a href="#10-6-3-dispatch-barrier-async" class="headerlink" title="10.6.3 dispatch_barrier_async"></a>10.6.3 dispatch_barrier_async</h3><ul>
<li>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的</li>
<li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/10/10.6.3_1.png" alt></p>
<h2 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1、请问下面代码的打印结果？"><a href="#1、请问下面代码的打印结果？" class="headerlink" title="1、请问下面代码的打印结果？"></a>1、请问下面代码的打印结果？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcd_example1 &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            NSLog(@&quot;index = %d,thread = %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果是：1、3</span><br><span class="line">原因</span><br><span class="line">performSelector:withObject:afterDelay:的本质是往Runloop中添加定时器</span><br><span class="line">子线程默认没有启动Runloop</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line">打印结果：1</span><br><span class="line">然后崩溃</span><br><span class="line"></span><br><span class="line">除非启动runloop保活子线程。</span><br></pre></td></tr></table></figure>
<h1 id="11、内存管理"><a href="#11、内存管理" class="headerlink" title="11、内存管理"></a>11、内存管理</h1><h2 id="11-1-定时器"><a href="#11-1-定时器" class="headerlink" title="11.1 定时器"></a>11.1 定时器</h2><h3 id="11-1-1-CADisplayLink、NSTimer使用注意"><a href="#11-1-1-CADisplayLink、NSTimer使用注意" class="headerlink" title="11.1.1 CADisplayLink、NSTimer使用注意"></a>11.1.1 CADisplayLink、NSTimer使用注意</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.1.1_1.png" alt></p>
<p>CADisplayLink、NSTimer会强引用target，如果target再强引用CADisplayLink、NSTimer会导致循环引用。解决办法引入一个中间对象，改为弱引用。如下图所示。NSProxy对象如果发现方法找不到直接进入消息转发流程，所以中间对象用继承自NSProxy的对象最合适，效率高。</p>
<p><img src="/2019/04/27/OC底层原理/imgs/11/11.1.1_2.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/11/11.1.1_3.png" alt></p>
<h3 id="11-1-2-GCD定时器"><a href="#11-1-2-GCD定时器" class="headerlink" title="11.1.2 GCD定时器"></a>11.1.2 GCD定时器</h3><ul>
<li>NSTimer依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时</li>
<li>而GCD的定时器会更加准时</li>
</ul>
<p><img src="/2019/04/27/OC底层原理/imgs/11/11.1.2_1.png" alt></p>
<h2 id="11-2-内存布局"><a href="#11-2-内存布局" class="headerlink" title="11.2 内存布局"></a>11.2 内存布局</h2><h3 id="11-2-1-iOS程序的内存布局"><a href="#11-2-1-iOS程序的内存布局" class="headerlink" title="11.2.1 iOS程序的内存布局"></a>11.2.1 iOS程序的内存布局</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.2.1_1.png" alt></p>
<h3 id="11-2-2-Tagged-Pointer"><a href="#11-2-2-Tagged-Pointer" class="headerlink" title="11.2.2 Tagged Pointer"></a>11.2.2 Tagged Pointer</h3><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</p>
<p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</p>
<p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中</p>
<p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</p>
<p>objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销</p>
<p>如何判断一个指针是否为Tagged Pointer？<br>iOS平台，最高有效位是1（第64bit）<br>Mac平台，最低有效位是1</p>
<h3 id="11-2-3-判断是否为Tagged-Pointer"><a href="#11-2-3-判断是否为Tagged-Pointer" class="headerlink" title="11.2.3 判断是否为Tagged Pointer"></a>11.2.3 判断是否为Tagged Pointer</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.2.3_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/11/11.2.3_2.png" alt></p>
<h2 id="11-3-对象的内存管理"><a href="#11-3-对象的内存管理" class="headerlink" title="11.3 对象的内存管理"></a>11.3 对象的内存管理</h2><h3 id="11-3-1-OC对象的内存管理"><a href="#11-3-1-OC对象的内存管理" class="headerlink" title="11.3.1 OC对象的内存管理"></a>11.3.1 OC对象的内存管理</h3><p>在iOS中，使用引用计数来管理OC对象的内存</p>
<p>一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p>
<p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p>
<p>内存管理的经验总结<br>当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它<br>想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1</p>
<p>可以通过以下私有函数来查看自动释放池的情况<br>extern void _objc_autoreleasePoolPrint(void);</p>
<p><img src="/2019/04/27/OC底层原理/imgs/11/11.3.1_1.png" alt><br><img src="/2019/04/27/OC底层原理/imgs/11/11.3.1_2.png" alt></p>
<h3 id="11-3-2-copy和mutableCopy"><a href="#11-3-2-copy和mutableCopy" class="headerlink" title="11.3.2 copy和mutableCopy"></a>11.3.2 copy和mutableCopy</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.3.2_1.png" alt></p>
<h3 id="11-3-3-引用计数的存储"><a href="#11-3-3-引用计数的存储" class="headerlink" title="11.3.3 引用计数的存储"></a>11.3.3 引用计数的存储</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.3.3_1.png" alt></p>
<h3 id="11-3-4-dealloc"><a href="#11-3-4-dealloc" class="headerlink" title="11.3.4 dealloc"></a>11.3.4 dealloc</h3><p>当一个对象要释放时，会自动调用dealloc，接下的调用轨迹是</p>
<p>dealloc<br>_objc_rootDealloc<br>rootDealloc<br>object_dispose<br>objc_destructInstance、free</p>
<p><img src="/2019/04/27/OC底层原理/imgs/11/11.3.4_1.png" alt></p>
<h2 id="11-4-自动释放池"><a href="#11-4-自动释放池" class="headerlink" title="11.4 自动释放池"></a>11.4 自动释放池</h2><h3 id="11-4-1-自动释放池"><a href="#11-4-1-自动释放池" class="headerlink" title="11.4.1 自动释放池"></a>11.4.1 自动释放池</h3><p>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage</p>
<p>调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的</p>
<p>源码分析<br>clang重写@autoreleasepool<br>objc4源码：NSObject.mm</p>
<p><img src="/2019/04/27/OC底层原理/imgs/11/11.4.1_1.png" alt></p>
<h3 id="11-4-2-AutoreleasePoolPage的结构"><a href="#11-4-2-AutoreleasePoolPage的结构" class="headerlink" title="11.4.2 AutoreleasePoolPage的结构"></a>11.4.2 AutoreleasePoolPage的结构</h3><p><img src="/2019/04/27/OC底层原理/imgs/11/11.4.2_1.png" alt></p>
<p>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p>
<p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release消息，直到遇到这个POOL_BOUNDARY</p>
<p>id *next指向了下一个能存放autorelease对象地址的区域  </p>
<h3 id="11-4-3-Runloop和Autorelease"><a href="#11-4-3-Runloop和Autorelease" class="headerlink" title="11.4.3 Runloop和Autorelease"></a>11.4.3 Runloop和Autorelease</h3><p>iOS在主线程的Runloop中注册了2个Observer<br>第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()<br>第2个Observer<br>监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()<br>监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/OC/" rel="tag"># OC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/26/github-hexo-打造个人网站/" rel="next" title="github + hexo 打造个人网站">
                <i class="fa fa-chevron-left"></i> github + hexo 打造个人网站
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/30/iOS-Crash-Log-解析/" rel="prev" title="iOS Crash Log 解析">
                iOS Crash Log 解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.gif" alt="Luckyvon">
            
              <p class="site-author-name" itemprop="name">Luckyvon</p>
              <div class="site-description motion-element" itemprop="description">不积跬步,无以至千里;不积小流,无以成江海。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/luckyvon" title="GitHub &rarr; https://github.com/luckyvon" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、OC对象的本质"><span class="nav-text">1、OC对象的本质</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-OC底层实现"><span class="nav-text">1.1 OC底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-将Objective-C代码转换为C-C-代码"><span class="nav-text">1.2 将Objective-C代码转换为C\C++代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-NSObject的底层实现"><span class="nav-text">1.3 NSObject的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-实时查看内存数据"><span class="nav-text">1.4 实时查看内存数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-ViewMemory"><span class="nav-text">1.4.1 ViewMemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-LLDB指令"><span class="nav-text">1.4.2 LLDB指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-结构体内存分配"><span class="nav-text">1.5 结构体内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-sizeof注意点"><span class="nav-text">1.6 sizeof注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题"><span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、OC对象的分类"><span class="nav-text">2、OC对象的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Objective-C中的对象，简称OC对象，主要可以分为3种"><span class="nav-text">2.1 Objective-C中的对象，简称OC对象，主要可以分为3种</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-instance"><span class="nav-text">2.1.1 instance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-class"><span class="nav-text">2.1.2 class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-meta-class"><span class="nav-text">2.1.3 meta-class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-注意"><span class="nav-text">2.1.4 注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-查看Class是否为meta-class"><span class="nav-text">2.1.5 查看Class是否为meta-class</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-object-getClass内部实现"><span class="nav-text">2.2 object_getClass内部实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-isa指针"><span class="nav-text">2.3 isa指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-class对象的superclass指针"><span class="nav-text">2.4 class对象的superclass指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-meta-class对象的superclass指"><span class="nav-text">2.5 meta-class对象的superclass指</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-isa、superclass总结"><span class="nav-text">2.6 isa、superclass总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-class结构体"><span class="nav-text">2.7 class结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-isa指针"><span class="nav-text">2.7.1 isa指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-objc4源码下载"><span class="nav-text">2.7.2 objc4源码下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-窥探struct-objc-class的结构"><span class="nav-text">2.7.3 窥探struct objc_class的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-1"><span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、KVO"><span class="nav-text">3、KVO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-未使用KVO监听的对象"><span class="nav-text">3.1 未使用KVO监听的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-使用了KVO监听的对象"><span class="nav-text">3.2 使用了KVO监听的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-查看-NSSet-AndNotify的存在"><span class="nav-text">3.3 查看_NSSet*AndNotify的存在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-NSSet-ValueAndNotify的内部实现"><span class="nav-text">3.4 _NSSet*ValueAndNotify的内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-KVO子类的内部方法"><span class="nav-text">3.5 KVO子类的内部方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-2"><span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、KVC"><span class="nav-text">4、KVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-概述"><span class="nav-text">4.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-setValue-forKey-的原理"><span class="nav-text">4.2 setValue:forKey:的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-valueForKey-的原理"><span class="nav-text">4.3 valueForKey:的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-3"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过KVC修改属性会触发KVO么？"><span class="nav-text">通过KVC修改属性会触发KVO么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVC的赋值和取值过程是怎样的？原理是什么？"><span class="nav-text">KVC的赋值和取值过程是怎样的？原理是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、Category"><span class="nav-text">5、Category</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Category的底层结构"><span class="nav-text">5.1 Category的底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Category的加载处理过程"><span class="nav-text">5.2 Category的加载处理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-load方法"><span class="nav-text">5.3 +load方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-initialize方法"><span class="nav-text">5.4 +initialize方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-4"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Category的实现原理"><span class="nav-text">1、Category的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Category和Class-Extension的区别是什么？"><span class="nav-text">2、Category和Class Extension的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、Category中有load方法吗？load方法是什么时候调用的？load-方法能继承吗？"><span class="nav-text">3、Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？"><span class="nav-text">4、load、initialize方法的区别什么？它们在category中的调用的顺序？以及出现继承时他们之间的调用过程？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、关联对象"><span class="nav-text">6、关联对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-如何实现给分类“添加成员变量”？"><span class="nav-text">6.1 如何实现给分类“添加成员变量”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-key的常见用"><span class="nav-text">6.2 key的常见用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-objc-AssociationPolicy"><span class="nav-text">6.3 objc_AssociationPolicy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-关联对象的原理"><span class="nav-text">6.4 关联对象的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、Block"><span class="nav-text">7、Block</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-block的本质"><span class="nav-text">7.1 block的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-block的变量捕获（capture）"><span class="nav-text">7.2 block的变量捕获（capture）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-block的类型"><span class="nav-text">7.3 block的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-block的copy"><span class="nav-text">7.4 block的copy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-对象类型的auto变量"><span class="nav-text">7.5 对象类型的auto变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-weak问题解决"><span class="nav-text">7.6 __weak问题解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-block修饰符"><span class="nav-text">7.7 __block修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-block的内存管理"><span class="nav-text">7.8 __block的内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-block的forwarding指针"><span class="nav-text">7.9 block的forwarding指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-对象类型的auto变量、-block变量"><span class="nav-text">7.10 对象类型的auto变量、__block变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-11-被-block修饰的对象类型"><span class="nav-text">7.11 被__block修饰的对象类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-12-循环引用问题"><span class="nav-text">7.12 循环引用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-1-解决循环引用问题-ARC"><span class="nav-text">7.12.1 解决循环引用问题 - ARC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-2-解决循环引用问题-MRC"><span class="nav-text">7.12.2 解决循环引用问题 - MRC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-5"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、block的原理是怎样的？本质是什么？"><span class="nav-text">1、block的原理是怎样的？本质是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、-block的作用是什么？有什么使用注意点？"><span class="nav-text">2、__block的作用是什么？有什么使用注意点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、block的属性修饰词为什么是copy？使用block有哪些使用注意？"><span class="nav-text">3、block的属性修饰词为什么是copy？使用block有哪些使用注意？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、block在修改NSMutableArray，需不需要添加-block？"><span class="nav-text">4、block在修改NSMutableArray，需不需要添加__block？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8、Runtime"><span class="nav-text">8、Runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-isa详解"><span class="nav-text">8.1 isa详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-isa简介"><span class="nav-text">8.1.1 isa简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-isa位域"><span class="nav-text">8.1.2 isa位域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Class"><span class="nav-text">8.2 Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-Class的结构"><span class="nav-text">8.2.1 Class的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-class-rw-t"><span class="nav-text">8.2.2 class_rw_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-class-ro-t"><span class="nav-text">8.2.3 class_ro_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4-method-t"><span class="nav-text">8.2.4 method_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5-Type-Encoding"><span class="nav-text">8.2.5 Type Encoding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-6-方法缓存"><span class="nav-text">8.2.6 方法缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-objc-msgSend"><span class="nav-text">8.3 objc_msgSend</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-执行流程"><span class="nav-text">8.3.1 执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-源码跟读"><span class="nav-text">8.3.2 源码跟读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-消息发送"><span class="nav-text">8.3.3 消息发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-4-动态方法解析"><span class="nav-text">8.3.4 动态方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-5-消息转发"><span class="nav-text">8.3.5 消息转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-super"><span class="nav-text">8.4 super</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-super的本质"><span class="nav-text">8.4.1 super的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-2-LLVM的中间代码（IR）"><span class="nav-text">8.4.2 LLVM的中间代码（IR）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-Runtime的应用"><span class="nav-text">8.5 Runtime的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-Runtime-API"><span class="nav-text">8.6 Runtime API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-类"><span class="nav-text">8.6.1 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-成员变量"><span class="nav-text">8.6.2 成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-3-属性"><span class="nav-text">8.6.3 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-4-方法"><span class="nav-text">8.6.4 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-6"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、讲一下-OC-的消息机制"><span class="nav-text">1、讲一下 OC 的消息机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、消息转发机制流程"><span class="nav-text">2、消息转发机制流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、消息转发机制流程"><span class="nav-text">3、消息转发机制流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9、RunLoop"><span class="nav-text">9、RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-简介"><span class="nav-text">9.1 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-1-什么是RunLoop"><span class="nav-text">9.1.1 什么是RunLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-2-如果没有RunLoop"><span class="nav-text">9.1.2 如果没有RunLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-3-如果有了RunLoop"><span class="nav-text">9.1.3 如果有了RunLoop</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-RunLoop对象"><span class="nav-text">9.2 RunLoop对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-RunLoop与线程"><span class="nav-text">9.2.1 RunLoop与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-获取RunLoop对象"><span class="nav-text">9.2.2 获取RunLoop对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-Mode"><span class="nav-text">9.3 Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-RunLoop相关的类"><span class="nav-text">9.3.1 RunLoop相关的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-CFRunLoopModeRef"><span class="nav-text">9.3.2 CFRunLoopModeRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-3-CFRunLoopObserverRef"><span class="nav-text">9.3.3 CFRunLoopObserverRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-4-添加Observer监听RunLoop的所有状态"><span class="nav-text">9.3.4 添加Observer监听RunLoop的所有状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-RunLoop的运行逻辑"><span class="nav-text">9.4 RunLoop的运行逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-RunLoop在实际开中的应用"><span class="nav-text">9.5 RunLoop在实际开中的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-7"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、讲讲-RunLoop，项目中有用到吗？"><span class="nav-text">1、讲讲 RunLoop，项目中有用到吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、runloop内部实现逻辑？"><span class="nav-text">2、runloop内部实现逻辑？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、runloop和线程的关系？"><span class="nav-text">3、runloop和线程的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、timer-与-runloop-的关系？"><span class="nav-text">4、timer 与 runloop 的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"><span class="nav-text">5、程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、runloop-是怎么响应用户操作的，-具体流程是什么样的？"><span class="nav-text">6、runloop 是怎么响应用户操作的， 具体流程是什么样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、说说runLoop的几种状态"><span class="nav-text">7、说说runLoop的几种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、runloop的mode作用是什么？"><span class="nav-text">8、runloop的mode作用是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10、多线程"><span class="nav-text">10、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-方案"><span class="nav-text">10.1 方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-1-iOS中的常见多线程方案"><span class="nav-text">10.1.1 iOS中的常见多线程方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-2-GCD的常用函数"><span class="nav-text">10.1.2 GCD的常用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-3-GCD的队列"><span class="nav-text">10.1.3 GCD的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-4-容易混淆的术语"><span class="nav-text">10.1.4 容易混淆的术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-5-各种队列的执行效果"><span class="nav-text">10.1.5 各种队列的执行效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-队列组的使用"><span class="nav-text">10.2 队列组的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-线程同步"><span class="nav-text">10.3 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-1-多线程的安全隐患"><span class="nav-text">10.3.1 多线程的安全隐患</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-2-存钱取钱"><span class="nav-text">10.3.2 存钱取钱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-3-卖票"><span class="nav-text">10.3.3 卖票</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-4-多线程安全隐患分析"><span class="nav-text">10.3.4 多线程安全隐患分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-5-多线程安全隐患的解决方案"><span class="nav-text">10.3.5 多线程安全隐患的解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-线程同步方案"><span class="nav-text">10.4 线程同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-1-iOS中的线程同步方案"><span class="nav-text">10.4.1 iOS中的线程同步方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-2-GNUstep"><span class="nav-text">10.4.2 GNUstep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-3-OSSpinLock"><span class="nav-text">10.4.3 OSSpinLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-4-os-unfair-lock"><span class="nav-text">10.4.4 os_unfair_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-5-pthread-mutex"><span class="nav-text">10.4.5 pthread_mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-6-NSLock、NSRecursiveLock"><span class="nav-text">10.4.6 NSLock、NSRecursiveLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-7-NSCondition"><span class="nav-text">10.4.7 NSCondition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-8-NSConditionLock"><span class="nav-text">10.4.8 NSConditionLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-9-dispatch-semaphore"><span class="nav-text">10.4.9 dispatch_semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-10-dispatch-queue"><span class="nav-text">10.4.10 dispatch_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-11-synchronized"><span class="nav-text">10.4.11 @synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-12-iOS线程同步方案性能比较"><span class="nav-text">10.4.12 iOS线程同步方案性能比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-13-自旋锁、互斥锁比较"><span class="nav-text">10.4.13 自旋锁、互斥锁比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-atomic"><span class="nav-text">10.5 atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-读写安全"><span class="nav-text">10.6 读写安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-1-iOS中的读写安全方案"><span class="nav-text">10.6.1 iOS中的读写安全方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-2-pthread-rwlock"><span class="nav-text">10.6.2 pthread_rwlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-3-dispatch-barrier-async"><span class="nav-text">10.6.3 dispatch_barrier_async</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题-8"><span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、请问下面代码的打印结果？"><span class="nav-text">1、请问下面代码的打印结果？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11、内存管理"><span class="nav-text">11、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-定时器"><span class="nav-text">11.1 定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-1-CADisplayLink、NSTimer使用注意"><span class="nav-text">11.1.1 CADisplayLink、NSTimer使用注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-2-GCD定时器"><span class="nav-text">11.1.2 GCD定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-内存布局"><span class="nav-text">11.2 内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-iOS程序的内存布局"><span class="nav-text">11.2.1 iOS程序的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-Tagged-Pointer"><span class="nav-text">11.2.2 Tagged Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-判断是否为Tagged-Pointer"><span class="nav-text">11.2.3 判断是否为Tagged Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-对象的内存管理"><span class="nav-text">11.3 对象的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-OC对象的内存管理"><span class="nav-text">11.3.1 OC对象的内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-copy和mutableCopy"><span class="nav-text">11.3.2 copy和mutableCopy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-3-引用计数的存储"><span class="nav-text">11.3.3 引用计数的存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-4-dealloc"><span class="nav-text">11.3.4 dealloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-自动释放池"><span class="nav-text">11.4 自动释放池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-1-自动释放池"><span class="nav-text">11.4.1 自动释放池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-2-AutoreleasePoolPage的结构"><span class="nav-text">11.4.2 AutoreleasePoolPage的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-3-Runloop和Autorelease"><span class="nav-text">11.4.3 Runloop和Autorelease</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luckyvon</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
